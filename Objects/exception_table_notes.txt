Description of the internal format of the exception table.

Conceptually, the exception table consists of a sequence of 5-tuples:
    start-offset (inclusive), end-offset (exclusive), target, stack-depth, push-lasti (boolean)

We want the format to be compact, but quickly searchable.
For it to be compact, it needs to have variable sized entries so that we can store common (small) offsets compactly, but handle large offsets if needed.
For it to be searchable quickly, we need to support binary search giving us log(n) performance in all cases.
Binary search typically assumes fixed size entries, but that is not necesary, as long as we can identify the start of an entry.

It is worth noting that the size (end-start) is always smaller that the end, so we encode the entries as:
    start, size, target, depth, push-lasti

Also, sizes are limited to 2**30 as the code lenght cannot exceed 2**31 and each instruction takes 2 bytes.
It also happens that depth is generally quie small, and cannot exceed about 140.

So, we need to encode:
    start (up to 30 bits)
    size (up to 30 bits)
    target (up to 30 bits)
    depth (up to ~8 bits)
    lasti (1 bit)

We need a marker for the start of the entry, so the first byte will always have the most significant bit set.
Since the most significant bit is reserved for marking the start of an entry, we have 7 bits per byte to encode offsets.
We will combine depth and lasti into ((depth<<1)+lasti) before encoding.
Encoding uses a standard varint encoding, but with only 7 bits instead of the usual 8.
The 8 bits of a bit are (msb left) SXdddddd where S is the start bit. X is the extend bit meaning that the next byte is required to extend the offset.

For example, the exception entry:
    start: 20
    end:   28
    target 100
    depth  3
    lasti  False

is encoded first by converting to the more compact four value form:
    start:        20
    size:         8
    target        100
  depth<<1+lasti  6

Where is then encoded as:
    148 (MSB + 20 for start)
    8   (size)
    65  (Extend bit + 1)
    36  (Remainder of target, 100 == (1<<6)+36)
    6

for a total of five bytes.


:mod:`!annotationlib` --- Functionality for introspecting annotations
=====================================================================

.. module:: annotationlib
   :synopsis: Functionality for introspecting annotations


**Source code:** :source:`Lib/annotationlib.py`

.. testsetup:: default

   import annotationlib
   from annotationlib import *

--------------

The :mod:`!annotationlib` module provides tools for introspecting :term:`annotations <annotation>`
on modules, classes, and functions.

.. function:: call_annotate_function(annotate, format, *, owner=None)

   Call the :term:`annotate function` *annotate* with the given *format*, a member of the :class:`Format`
   enum, and return the annotations dictionary produced by the function.

   Annotate functions generated by the compiler for functions, classes, and modules support only
   the :attr:`~Format.VALUE` format when called directly. This function calls the annotate function
   in a special environment that allows it to produce annotations in the other formats.

   *owner* is the object that owns the annotation function, usually a function, class, or module.
   If provided, it is used in the :attr:`~Format.FORWARDREF` format to produce a :class:`ForwardRef`
   object that carry more information.

   .. versionadded:: 3.14

.. class:: Format

   An :class:`~enum.IntEnum` describing the formats in which annotations can be returned.
   Members of the enum, or their equivalent integer values, can be passed to
   :func:`get_annotations` and other functions in this module, as well as to
   :attr:`~object.__annotate__` functions.

   .. attribute:: VALUE

      Values are the result of evaluating the annotation expressions.

      This enum member's value is equal to 1.

   .. attribute:: FORWARDREF

      Values are real annotation values (as per :attr:`Format.VALUE` format) for defined values,
      and :class:`ForwardRef` proxies for undefined values. Real objects may be exposed to,
      or contain references to, :class:`ForwardRef` proxy objects.

      This enum member's value is equal to 2.

   .. attribute:: SOURCE

      Values are the text string of the annotation as it appears in the source code,
      up to modifications including, but not restricted to, whitespace normalizations
      and constant values optimizations.

      The exact values of these strings may change in future versions of Python.

   .. versionadded:: 3.14

.. class:: ForwardRef

   A proxy object for forward references in annotations.

   Instances of this class are returned when the :attr:`~Format.FORWARDREF` format is
   used and annotations contain a name that cannot be resolved.  This can happen
   when a forward reference is used in an annotation, such as when a class is
   referenced before it is defined.

   .. attribute:: __forward_arg__

      A string containing the code that was evaluated to produce the :class:`~ForwardRef`.
      The string may not be exactly equivalent to the original source.

   .. method:: evaluate(*, globals=None, locals=None, type_params=None, owner=None)

      Evaluate the forward reference, returning its value.

      This may throw an exception such as :exc:`NameError` if the forward reference
      refers to names that do not exist. The parameters to the function can be used to
      provide bindings for names that would otherwise be undefined.

      *globals* and *locals* are passed to :func:`eval()`, representing the global and
      local namespaces in which the name is evaluated. *type_params*, if given, must be
      a tuple of :ref:`type parameters <type-params>` that are in scope while the forward
      reference is being evaluated. *owner* is the object that owns the annotation from
      which the forward reference derives, usually a function, class, or module.
      :class:`~ForwardRef` instances returned by :func:`get_annotations` retain
      a reference to their owner, so it is not necessary to pass it in explicitly.

      Once a :class:`~ForwardRef` instance has been evaluated, it caches the evaluated
      value, and future calls to :meth:`evaluate` will return the cached value, regardless
      of the parameters passed in.

   .. versionadded:: 3.14

.. function:: get_annotate_function(obj)

   Retrieve the :term:`annotate function` for *obj*. Return ``None`` if *obj* does not have an
   annotate function.

   This is usually equivalent to accessing the :attr:`~object.__annotate__` attribute of *obj*,
   but direct access to the attribute may return the wrong object in certain situations involving
   metaclasses. It is recommended to use this function instead of accessing the attribute directly.

   .. versionadded:: 3.14

.. function:: get_annotations(obj, *, globals=None, locals=None, eval_str=False, format=Format.VALUE)

   Compute the annotations dict for an object.

   *obj* may be a callable, class, module, or other object with
   :attr:`~object.__annotate__` and :attr:`~object.__annotations__` attributes.
   Passing in an object of any other type raises :exc:`TypeError`.

   The *format* parameter controls the format in which annotations are returned.

   Returns a dict.  ``get_annotations()`` returns a new dict every time
   it's called; calling it twice on the same object will return two
   different but equivalent dicts.

   This function handles several details for you:

   * If *eval_str* is true, values of type ``str`` will
     be un-stringized using :func:`eval`.  This is intended
     for use with stringized annotations
     (``from __future__ import annotations``). It is an error
     to set ``eval_str`` to true with formats other than :attr:`Format.VALUE`.
   * If ``obj`` doesn't have an annotations dict, returns an
     empty dict.  (Functions and methods always have an
     annotations dict; classes, modules, and other types of
     callables may not.)
   * Ignores inherited annotations on classes, as well as annotations
     on metaclasses.  If a class
     doesn't have its own annotations dict, returns an empty dict.
   * All accesses to object members and dict values are done
     using ``getattr()`` and ``dict.get()`` for safety.
   * Always, always, always returns a freshly created dict.

   ``eval_str`` controls whether or not values of type ``str`` are replaced
   with the result of calling :func:`eval()` on those values:

   * If eval_str is true, :func:`eval()` is called on values of type ``str``.
     (Note that ``get_annotations`` doesn't catch exceptions; if :func:`eval()`
     raises an exception, it will unwind the stack past the ``get_annotations``
     call.)
   * If *eval_str* is false (the default), values of type ``str`` are unchanged.

   ``globals`` and ``locals`` are passed in to :func:`eval()`; see the documentation
   for :func:`eval()` for more information.  If ``globals`` or ``locals``
   is ``None``, this function may replace that value with a context-specific
   default, contingent on ``type(obj)``:

   * If ``obj`` is a module, ``globals`` defaults to ``obj.__dict__``.
   * If ``obj`` is a class, ``globals`` defaults to
     ``sys.modules[obj.__module__].__dict__`` and ``locals`` defaults
     to the ``obj`` class namespace.
   * If ``obj`` is a callable, ``globals`` defaults to
     :attr:`obj.__globals__ <function.__globals__>`,
     although if ``obj`` is a wrapped function (using
     :func:`functools.update_wrapper`) it is first unwrapped.

   Calling :func:`!get_annotations` is best practice for accessing the
   annotations dict of any object.  See :ref:`annotations-howto` for
   more information on annotations best practices.

   .. doctest::

      >>> def f(a: int, b: str) -> float:
      ...     pass
      >>> get_annotations(f)
      {'a': <class 'int'>, 'b': <class 'str'>, 'return': <class 'float'>}

   .. versionadded:: 3.14

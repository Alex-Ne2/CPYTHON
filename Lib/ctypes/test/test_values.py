"""
A testcase which accesses *values* in a dll.
"""

import unittest
import sys
from ctypes import *

import _ctypes_test

class ValuesTestCase(unittest.TestCase):

    def test_an_integer(self):
        # This test checks and changes an integer stored inside the
        # _ctypes_test dll/shared lib.
        ctdll = CDLL(_ctypes_test.__file__)
        an_integer = c_int.in_dll(ctdll, "an_integer")
        x = an_integer.value
        self.assertEqual(x, ctdll.get_an_integer())
        an_integer.value *= 2
        self.assertEqual(x*2, ctdll.get_an_integer())
        # To avoid test failures when this test is repeated several
        # times the original value must be restored
        an_integer.value = x
        self.assertEqual(x, ctdll.get_an_integer())

    def test_undefined(self):
        ctdll = CDLL(_ctypes_test.__file__)
        self.assertRaises(ValueError, c_int.in_dll, ctdll, "Undefined_Symbol")

class PythonValuesTestCase(unittest.TestCase):
    """This test only works when python itself is a dll/shared library"""

    def test_optimizeflag(self):
        # This test accesses the Py_OptimizeFlag integer, which is
        # exported by the Python dll and should match the sys.flags value

        opt = c_int.in_dll(pythonapi, "Py_OptimizeFlag").value
        self.assertEqual(opt, sys.flags.optimize)

    def test_frozentable(self):
        # Python exports a PyImport_FrozenModules symbol. This is a
        # pointer to an array of struct _frozen entries.  The end of the
        # array is marked by an entry containing a NULL name and zero
        # size.

        # In standard Python, this table contains a __hello__
        # module, and a __phello__ package containing a spam
        # module.
        class struct_frozen(Structure):
            _fields_ = [("name", c_char_p),
                        ("code", POINTER(c_ubyte)),
                        ("size", c_int)]
        FrozenTable = POINTER(struct_frozen)

        ft = FrozenTable.in_dll(pythonapi, "PyImport_FrozenModules")
        # ft is a pointer to the struct_frozen entries:
        items = []
        # _frozen_importlib changes size whenever importlib._bootstrap
        # changes, so it gets a special case.  We should make sure it's
        # found, but don't worry about its size too much.  The same
        # applies to _frozen_importlib_external.
        bootstrap_seen = []
        bootstrap_expected = [
                b'_frozen_importlib',
                b'_frozen_importlib_external',
                b'zipimport',
                ]
        for entry in ft:
            # This is dangerous. We *can* iterate over a pointer, but
            # the loop will not terminate (maybe with an access
            # violation;-) because the pointer instance has no size.
            if entry.name is None:
                break

            if entry.name in bootstrap_expected:
                bootstrap_seen.append(entry.name)
                self.assertTrue(entry.size,
                    "{!r} was reported as having no size".format(entry.name))
            items.append((entry.name.decode("ascii"), entry.size))

        expected = [
                # BEGIN: frozen modules
                # Auto-generated by Tools/scripts/freeze_modules.py
                ("_frozen_importlib", 41232),
                ("_frozen_importlib_external", 57582),
                ("zipimport", 23349),
                ("abc", 7872),
                ("codecs", 38863),
                ("encodings", -5250),
                ("encodings.__init__", 5259),
                ("encodings.aliases", 16890),
                ("encodings.ascii", 2257),
                ("encodings.base64_codec", 2799),
                ("encodings.big5", 1742),
                ("encodings.big5hkscs", 1752),
                ("encodings.bz2_codec", 3871),
                ("encodings.charmap", 3361),
                ("encodings.cp037", 2824),
                ("encodings.cp1006", 2900),
                ("encodings.cp1026", 2828),
                ("encodings.cp1125", 14743),
                ("encodings.cp1140", 2814),
                ("encodings.cp1250", 2851),
                ("encodings.cp1251", 2848),
                ("encodings.cp1252", 2851),
                ("encodings.cp1253", 2864),
                ("encodings.cp1254", 2853),
                ("encodings.cp1255", 2872),
                ("encodings.cp1256", 2850),
                ("encodings.cp1257", 2858),
                ("encodings.cp1258", 2856),
                ("encodings.cp273", 2810),
                ("encodings.cp424", 2854),
                ("encodings.cp437", 14192),
                ("encodings.cp500", 2824),
                ("encodings.cp720", 2921),
                ("encodings.cp737", 14768),
                ("encodings.cp775", 14258),
                ("encodings.cp850", 13607),
                ("encodings.cp852", 14288),
                ("encodings.cp855", 14733),
                ("encodings.cp856", 2886),
                ("encodings.cp857", 13368),
                ("encodings.cp858", 13577),
                ("encodings.cp860", 14151),
                ("encodings.cp861", 14190),
                ("encodings.cp862", 14521),
                ("encodings.cp863", 14182),
                ("encodings.cp864", 14273),
                ("encodings.cp865", 14190),
                ("encodings.cp866", 14781),
                ("encodings.cp869", 14150),
                ("encodings.cp874", 2952),
                ("encodings.cp875", 2821),
                ("encodings.cp932", 1744),
                ("encodings.cp949", 1744),
                ("encodings.cp950", 1744),
                ("encodings.euc_jis_2004", 1758),
                ("encodings.euc_jisx0213", 1758),
                ("encodings.euc_jp", 1746),
                ("encodings.euc_kr", 1746),
                ("encodings.gb18030", 1748),
                ("encodings.gb2312", 1746),
                ("encodings.gbk", 1740),
                ("encodings.hex_codec", 2786),
                ("encodings.hp_roman8", 3025),
                ("encodings.hz", 1738),
                ("encodings.idna", 8317),
                ("encodings.iso2022_jp", 1759),
                ("encodings.iso2022_jp_1", 1763),
                ("encodings.iso2022_jp_2", 1763),
                ("encodings.iso2022_jp_2004", 1769),
                ("encodings.iso2022_jp_3", 1763),
                ("encodings.iso2022_jp_ext", 1767),
                ("encodings.iso2022_kr", 1759),
                ("encodings.iso8859_1", 2823),
                ("encodings.iso8859_10", 2828),
                ("encodings.iso8859_11", 2922),
                ("encodings.iso8859_13", 2831),
                ("encodings.iso8859_14", 2849),
                ("encodings.iso8859_15", 2828),
                ("encodings.iso8859_16", 2830),
                ("encodings.iso8859_2", 2823),
                ("encodings.iso8859_3", 2830),
                ("encodings.iso8859_4", 2823),
                ("encodings.iso8859_5", 2824),
                ("encodings.iso8859_6", 2868),
                ("encodings.iso8859_7", 2831),
                ("encodings.iso8859_8", 2862),
                ("encodings.iso8859_9", 2823),
                ("encodings.johab", 1744),
                ("encodings.koi8_r", 2875),
                ("encodings.koi8_t", 2786),
                ("encodings.koi8_u", 2861),
                ("encodings.kz1048", 2838),
                ("encodings.latin_1", 2269),
                ("encodings.mac_arabic", 14064),
                ("encodings.mac_croatian", 2870),
                ("encodings.mac_cyrillic", 2860),
                ("encodings.mac_farsi", 2804),
                ("encodings.mac_greek", 2844),
                ("encodings.mac_iceland", 2863),
                ("encodings.mac_latin2", 3004),
                ("encodings.mac_roman", 2861),
                ("encodings.mac_romanian", 2871),
                ("encodings.mac_turkish", 2864),
                ("encodings.mbcs", 2024),
                ("encodings.oem", 1837),
                ("encodings.palmos", 2851),
                ("encodings.ptcp154", 2945),
                ("encodings.punycode", 8710),
                ("encodings.quopri_codec", 2923),
                ("encodings.raw_unicode_escape", 2099),
                ("encodings.rot_13", 4075),
                ("encodings.shift_jis", 1752),
                ("encodings.shift_jis_2004", 1762),
                ("encodings.shift_jisx0213", 1762),
                ("encodings.tis_620", 2913),
                ("encodings.undefined", 2421),
                ("encodings.unicode_escape", 2079),
                ("encodings.utf_16", 6365),
                ("encodings.utf_16_be", 1953),
                ("encodings.utf_16_le", 1953),
                ("encodings.utf_32", 6256),
                ("encodings.utf_32_be", 1846),
                ("encodings.utf_32_le", 1846),
                ("encodings.utf_7", 1874),
                ("encodings.utf_8", 1933),
                ("encodings.utf_8_sig", 5674),
                ("encodings.uu_codec", 4202),
                ("encodings.zlib_codec", 3605),
                ("io", 4282),
                ("_collections_abc", 43188),
                ("_sitebuiltins", 4647),
                ("genericpath", 4929),
                ("posixpath", 15014),
                ("os.path", 15014),
                ("os", 40423),
                ("site", 22838),
                ("stat", 5345),
                ("__hello__", 164),
                ("__phello__", -164),
                ("__phello__.spam", 164),
                # END: frozen modules
                ]
        self.maxDiff = None
        self.assertEqual(items, expected, "PyImport_FrozenModules example "
            "in Doc/library/ctypes.rst may be out of date")

        self.assertEqual(sorted(bootstrap_seen), bootstrap_expected,
            "frozen bootstrap modules did not match PyImport_FrozenModules")

        from ctypes import _pointer_type_cache
        del _pointer_type_cache[struct_frozen]

    def test_undefined(self):
        self.assertRaises(ValueError, c_int.in_dll, pythonapi,
                          "Undefined_Symbol")

if __name__ == '__main__':
    unittest.main()

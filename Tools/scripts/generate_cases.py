"""Generate the main interpreter switch."""

# Write the cases to cases.h, which can be #included in ceval.c.

# TODO: Reuse C generation framework from deepfreeze.py?

import argparse
from dataclasses import dataclass
import dis
import re
import sys

parser = argparse.ArgumentParser()
parser.add_argument("-i", "--input", type=str, default="Python/bytecodes.inst")
parser.add_argument("-o", "--output", type=str, default="Python/cases.h")
parser.add_argument("-c", "--compare", action="store_true")
parser.add_argument("-q", "--quiet", action="store_true")


def eopen(filename, mode="r"):
    if filename == "-":
        if "r" in mode:
            return sys.stdin
        else:
            return sys.stdout
    return open(filename, mode)


def leading_whitespace(line):
    return len(line) - len(line.lstrip())


@dataclass
class Instruction:
    opcode_name: str
    inputs: list[str]
    outputs: list[str]
    c_code: list[str]  # Excludes outer {}, no trailing \n


HEADER_REGEX = r"""(?x)
^
inst
\s*
\(
    \s*
    (\w+)
    \s*
    ,
    \s*
    \(
        (.*)
        --
        (.*)
    \)
\)
\s*
{
\s*
$
"""

def parse_instrs(f):
    """Parse the DSL file and return a list of (opcode_name, stack_effect) pairs."""
    instrs = []
    # TODO: Count line numbers
    while raw := f.readline():
        indent = leading_whitespace(raw)
        line = raw.strip()
        if not line or line.startswith("//"):
            continue
        if m := re.match(HEADER_REGEX, line):
            name, input, output = m.groups()
            inputs = [s.strip() for s in input.split(",")]
            outputs = [s.strip() for s in output.split(",")]
            c_code = []
            while raw := f.readline():
                line = raw.rstrip()
                indent2 = leading_whitespace(line)
                line = line.strip()
                if not indent2 and not line:
                    # Totally blank line
                    c_code.append("")
                    continue
                if indent2 == indent and line == "}":
                    # Correctly placed closing brace
                    break
                if indent2 < indent:
                    raise ValueError(f"Unexpected dedent: {line!r}")
                if raw[:indent] != " "*indent:
                    raise ValueError(f"Bad indent: {line!r}")
                c_code.append(raw[indent:].rstrip())
            instr = Instruction(name, inputs, outputs, c_code)
            instrs.append(instr)
        else:
            raise ValueError(f"Unexpected line: {line!r}")
    return instrs


def write_cases(f, instrs):
    indent = "        "
    f.write("// This file is generated by Tools/scripts/generate_cases.py\n")
    f.write("// Do not edit!\n")
    for instr in instrs:
        f.write(f"\n{indent}TARGET({instr.opcode_name}) {{\n")
        input = ", ".join(instr.inputs)
        output = ", ".join(instr.outputs)
        # f.write(f"{indent}    // {input} -- {output}\n")
        for line in instr.c_code:
            if line:
                f.write(f"{indent}{line}\n")
            else:
                f.write("\n")
        f.write(f"{indent}}}\n")


def main():
    args = parser.parse_args()
    with eopen(args.input) as f:
        instrs = parse_instrs(f)
    if not args.quiet:
        print(
            f"Read {len(instrs)} instructions from {args.input}", 
            file=sys.stderr,
        )
    with eopen(args.output, "w") as f:
        write_cases(f, instrs)
    if not args.quiet:
        print(
            f"Wrote {len(instrs)} instructions to {args.output}",
            file=sys.stderr,
        )


if __name__ == "__main__":
    main()

"""Generate the main interpreter switch."""

# Write the cases to cases.h, which can be #included in ceval.c.

# TODO: Reuse C generation framework from deepfreeze.py?

import argparse
from dataclasses import dataclass
import dis
import re
import sys

import lexer
import parser

arg_parser = argparse.ArgumentParser()
arg_parser.add_argument("-i", "--input", type=str, default="Python/bytecodes.c")
arg_parser.add_argument("-o", "--output", type=str, default="Python/cases.h")
arg_parser.add_argument("-c", "--compare", action="store_true")
arg_parser.add_argument("-q", "--quiet", action="store_true")


def eopen(filename, mode="r"):
    if filename == "-":
        if "r" in mode:
            return sys.stdin
        else:
            return sys.stdout
    return open(filename, mode)


def leading_whitespace(line):
    return len(line) - len(line.lstrip())


@dataclass
class Instruction:
    opcode_name: str
    inputs: list[str]
    outputs: list[str]
    c_code: list[str]  # Excludes outer {}, no trailing \n


def parse_cases(src, filename):
    psr = parser.Parser(src, filename=filename)
    instrs = []
    families = []
    while not psr.eof():
        if inst := psr.inst_header():
            blob = psr.c_blob()
            blobtext = lexer.to_text(blob)
            bloblines = blobtext.splitlines()
            if not psr.expect(lexer.RBRACE):
                raise psr.make_syntax_error("No '}' at end of code block")
            instrs.append(Instruction(inst.name, inst.inputs, inst.outputs, bloblines))
        elif fam := psr.family_def():
            families.append(fam)
        else:
            raise psr.make_syntax_error(f"Unexpected token {psr.peek().text!r}")
    return instrs, families


def write_cases(f, instrs):
    indent = "        "
    f.write("// This file is generated by Tools/scripts/generate_cases.py\n")
    f.write("// Do not edit!\n")
    for instr in instrs:
        assert isinstance(instr, Instruction)
        f.write(f"\n{indent}TARGET({instr.opcode_name}) {{\n")
        input = ", ".join(instr.inputs)
        output = ", ".join(instr.outputs)
        # f.write(f"{indent}    // {input} -- {output}\n")
        for line in instr.c_code:
            if line:
                f.write(f"{line}\n")
            else:
                f.write("\n")
        f.write(f"{indent}}}\n")


def main():
    args = arg_parser.parse_args()
    with eopen(args.input) as f:
        srclines = f.read().splitlines()
    begin = srclines.index("// BEGIN BYTECODES //")
    end = srclines.index("// END BYTECODES //")
    src = "\n".join(srclines[begin+1 : end])
    instrs, families = parse_cases(src, filename=args.input)
    if not args.quiet:
        ninstrs = len(instrs)
        nfamilies = len(families)
        print(
            f"Read {ninstrs} instructions "
            f"and {nfamilies} families from {args.input}",
            file=sys.stderr,
        )
    with eopen(args.output, "w") as f:
        write_cases(f, instrs)
    if not args.quiet:
        print(
            f"Wrote {ninstrs} instructions to {args.output}",
            file=sys.stderr,
        )


if __name__ == "__main__":
    main()

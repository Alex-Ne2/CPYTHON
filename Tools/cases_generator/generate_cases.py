"""Generate the main interpreter switch."""

# Write the cases to cases.h, which can be #included in ceval.c.

# TODO: Reuse C generation framework from deepfreeze.py?

import argparse
from dataclasses import dataclass
import dis
import re
import sys

import lexer
import parser

arg_parser = argparse.ArgumentParser()
arg_parser.add_argument("-i", "--input", type=str, default="Python/bytecodes.inst")
arg_parser.add_argument("-o", "--output", type=str, default="Python/cases.h")
arg_parser.add_argument("-c", "--compare", action="store_true")
arg_parser.add_argument("-q", "--quiet", action="store_true")
arg_parser.add_argument("-x", "--experimental", action="store_true")


def eopen(filename, mode="r"):
    if filename == "-":
        if "r" in mode:
            return sys.stdin
        else:
            return sys.stdout
    return open(filename, mode)


def leading_whitespace(line):
    return len(line) - len(line.lstrip())


@dataclass
class Instruction:
    opcode_name: str
    inputs: list[str]
    outputs: list[str]
    c_code: list[str]  # Excludes outer {}, no trailing \n


@dataclass
class Family:
    family_name: str
    members: list[str]


INST_REGEX = r"""(?x)
^
inst
\s*
\(
    \s*
    (\w+)
    \s*
    ,
    \s*
    \(
        (.*)
        --
        (.*)
    \)
\)
\s*
{
\s*
$
"""

FAMILY_REGEX = r"""(?x)
^
family
\s*
\(
    \s*
    (\w+)
    \s*
\)
\s*
=
(.*)
;
\s*
$
"""

def parse_instrs(f):
    """Parse the DSL file and return a list of (opcode_name, stack_effect) pairs."""
    instrs = []
    # TODO: Count line numbers
    while raw := f.readline():
        indent = leading_whitespace(raw)
        line = raw.strip()
        if not line or line.startswith("//"):
            continue
        if m := re.match(INST_REGEX, line):
            name, input, output = m.groups()
            inputs = [s.strip() for s in input.split(",")]
            outputs = [s.strip() for s in output.split(",")]
            c_code = []
            while raw := f.readline():
                line = raw.rstrip()
                indent2 = leading_whitespace(line)
                line = line.strip()
                if not indent2 and not line:
                    # Totally blank line
                    c_code.append("")
                    continue
                if indent2 == indent and line == "}":
                    # Correctly placed closing brace
                    break
                if indent2 < indent:
                    raise ValueError(f"Unexpected dedent: {line!r}")
                if raw[:indent] != " "*indent:
                    raise ValueError(f"Bad indent: {line!r}")
                c_code.append(raw[indent:].rstrip())
            instr = Instruction(name, inputs, outputs, c_code)
            instrs.append(instr)
        elif m := re.match(FAMILY_REGEX, line):
            name, memberlist = m.groups()
            members = [mbr.strip() for mbr in memberlist.split("+")]
            family = Family(name, members)
            instrs.append(family)
        else:
            raise ValueError(f"Unexpected line: {line!r}")
    return instrs


def write_cases(f, instrs):
    indent = "        "
    f.write("// This file is generated by Tools/scripts/generate_cases.py\n")
    f.write("// Do not edit!\n")
    for instr in instrs:
        if isinstance(instr, Family):
            continue  # Families are not written
        assert isinstance(instr, Instruction)
        f.write(f"\n{indent}TARGET({instr.opcode_name}) {{\n")
        input = ", ".join(instr.inputs)
        output = ", ".join(instr.outputs)
        # f.write(f"{indent}    // {input} -- {output}\n")
        for line in instr.c_code:
            if line:
                f.write(f"{indent}{line}\n")
            else:
                f.write("\n")
        f.write(f"{indent}}}\n")


def main():
    args = arg_parser.parse_args()
    if args.experimental:
        with eopen(args.input) as f:
            src = f.read()
        psr = parser.Parser(src)
        while inst := psr.inst_header():
            print(inst)
            blob = psr.c_blob()
            print(lexer.to_text(blob))
            assert psr.expect(lexer.RBRACE)
        while fam := psr.family_def():
            print(fam)
        if not psr.eof():
            print("Unexpected input:")
            for i in range(10):
                print(psr.next())
            breakpoint()
        return
    with eopen(args.input) as f:
        instrs = parse_instrs(f)
    if not args.quiet:
        ninstrs = sum(isinstance(instr, Instruction) for instr in instrs)
        nfamilies = sum(isinstance(instr, Family) for instr in instrs)
        print(
            f"Read {ninstrs} instructions "
            f"and {nfamilies} families from {args.input}",
            file=sys.stderr,
        )
    with eopen(args.output, "w") as f:
        write_cases(f, instrs)
    if not args.quiet:
        print(
            f"Wrote {ninstrs} instructions to {args.output}",
            file=sys.stderr,
        )


if __name__ == "__main__":
    main()

import sys
from analyzer import Analysis, Instruction, Uop, Part, analyze_file, Skip, StackItem, analysis_error
from cwriter import CWriter
from typing import Tuple, TextIO, Iterator
from lexer import Token
from dataclasses import dataclass

def write_header(filename: str, outfile: TextIO) -> None:
    outfile.write(f"""// This file is generated by {__file__}
// from:
//   {filename}
// Do not edit!

#ifdef TIER_TWO
    #error "This file is for Tier 1 only"
#endif
#define TIER_ONE 1
""")

FOOTER = "#undef TIER_ONE\n"

class SizeMismatch(Exception):
    pass

@dataclass
class StackEntry:
    name: str
    size: str
    offset: list[str]
    array: bool
    condition: str

    def __str__(self):
        return f"StackEntry({self.name}, {self.size}, {prettify_number(self.offset)})"

def prettify_number(offset: list[str]):
    int_offset = 0
    symbol_offset = ""
    for item in offset:
        try:
            int_offset += int(item)
        except ValueError:
            symbol_offset += f"+({item})"
    if symbol_offset and not int_offset:
        return symbol_offset
    res = f"{int_offset}{symbol_offset}"
    if res[0] == "+":
        res = res[1:]
    return res

class Stack:

    def __init__(self):
        self.offset: list[str] = []
        self.entries: list[StackEntry] = []
        self.defined: Set[str] = set()

    def pop(self, var: StackItem) -> str:
        indirect = "&" if var.is_array() else ""
        if self.entries:
            popped = self.entries.pop()
            if popped.size != var.size:
                raise SizeMismatch(f"Size mismatch when popping '{popped.name}' from stack to assign to {var.name}. "
                                   f"Expected {var.size} got {popped.size}")
            if popped.name == var.name:
                return ""
            elif popped.name == "unused":
                self.defined.add(var.name)
                return f"{var.name} = {indirect}stack_pointer[{prettify_number(popped.offset)}];"
            elif var.name == "unused":
                return ""
            else:
                self.defined.add(var.name)
                return f"{var.name} = {popped.name};"
        self.offset.append(f"-{var.size}")
        if var.name == "unused":
            return ""
        else:
            self.defined.add(var.name)
            return f"{var.name} = {indirect}stack_pointer[{prettify_number(self.offset)}];"

    def push(self, var: StackItem) -> None:
        if self.entries:
            tos = self.entries[-1]
            offset = tos.offset + [tos.size]
        else:
            offset = self.offset[:]
        if var.cond:
            size = f"(({var.cond}) ? {var.size} : 0)"
        else:
            size = var.size
        self.entries.append(StackEntry(var.name, size, offset, var.is_array(), var.cond))
        if var.is_array() and var.name not in self.defined and var.name != "unused":
            self.defined.add(var.name)
            return f"{var.name} = &stack_pointer[{prettify_number(offset)}];"
        else:
            return ""

    def flush(self, out: CWriter) -> None:
        for var in self.entries:
            if var.name != "unused" and not var.array:
                if var.condition:
                    out.emit(f" if ({var.condition}) ")
                out.emit(f"stack_pointer[{prettify_number(var.offset)}] = {var.name};")
            self.offset = var.offset + [ var.size]
        number = prettify_number(self.offset)
        if number != "0":
            out.emit(f"stack_pointer += {number};")
        self.entries = []
        self.offset = []

    def get_offset(self) -> str:
        return prettify_number(self.offset)

def declare_variables(inst: Instruction, out: CWriter)->None:
    variables = {}
    for uop in inst.uops:
        if isinstance(uop, Uop):
            for var in uop.stack.inputs:
                variables[var.name] = var.type if var.type else "PyObject *"
            for var in uop.stack.outputs:
                variables[var.name] = var.type if var.type else "PyObject *"
            for cache in uop.caches:
                if cache.name != "unused":
                    if cache.size == 4:
                        variables[cache.name] = f"PyObject *"
                    else:
                        variables[cache.name] = f"uint{cache.size*16}_t "
    for name, type in sorted(variables.items()):
        if name != "unused":
            out.emit(f"{type}{name};")

def emit_to(out: CWriter, tkn_iter: Iterator[Token], end: str):
    parens = 0
    for tkn in tkn_iter:
        if tkn.kind == end and parens == 0:
            return
        if tkn.kind == "LPAREN":
            parens += 1
        if tkn.kind == "RPAREN":
            parens -= 1
        out.emit(tkn)

def replace_deopt(out: CWriter, tkn_iter: Iterator[Token], uop: Uop, stack: Stack, inst: Instruction):
    parens = 0
    out.emit("DEOPT_IF")
    out.emit(next(tkn_iter))
    emit_to(out, tkn_iter, "RPAREN")
    out.emit(", ")
    out.emit(inst.family.name)
    out.emit(")")

def replace_error(out: CWriter, tkn_iter: Iterator[Token], uop: Uop, stack: Stack, inst: Instruction):
    out.emit("if ")
    out.emit(next(tkn_iter))
    emit_to(out, tkn_iter, "COMMA")
    label = next(tkn_iter).text
    next(tkn_iter)
    out.emit(") ")
    try:
        offset = -int(stack.get_offset())
        close = ""
    except ValueError:
        offset = None
        out.emit(f"{{ stack_pointer += {stack.get_offset()}; ")
        close = "}"
    out.emit("goto ")
    if offset:
        out.emit(f"pop_{offset}_")
    out.emit(label)
    out.emit(";")
    if close:
        out.emit(close)

def replace_decrefs(out: CWriter, tkn_iter: Iterator[Token], uop: Uop, stack: Stack, inst: Instruction):
    next(tkn_iter)
    next(tkn_iter)
    for var in uop.stack.inputs:
        if var.name != "unused" and var.name != "null":
            out.emit(f"Py_DECREF({var.name}); ")



REPLACEMENT_FUNCTIONS = {
    "DEOPT_IF" : replace_deopt,
    "ERROR_IF" : replace_error,
    "DECREF_INPUTS": replace_decrefs
}

#Move this to formatter
def emit_tokens(out: CWriter, uop: Uop, stack: Stack, inst: Instruction) -> None:
    tkn_iter = iter(uop.body)
    for tkn in tkn_iter:
        if tkn.kind == "IDENTIFIER" and tkn.text in REPLACEMENT_FUNCTIONS:
            # Align output
            out.emit(Token(tkn.kind, "", tkn.begin, tkn.end))
            REPLACEMENT_FUNCTIONS[tkn.text](out, tkn_iter, uop, stack, inst)
        else:
            out.emit(tkn)

def write_uop(uop: Part, out: CWriter, offset: int, stack: Stack, inst: Instruction) -> int:
    try:
        if isinstance(uop, Skip):
            out.emit(f"/* Skip {uop.size} cache entrie(s) */\n")
            return offset + uop.size
        out.emit(f"// {uop.name}\n")
        for var in reversed(uop.stack.inputs):
            out.emit(stack.pop(var))
        for i, var in enumerate(uop.stack.outputs):
            out.emit(stack.push(var))
        for cache in uop.caches:
            if cache.name != "unused":
                cast = "(PyObject *)" if cache.size == 4 else ""
                out.emit(f"{cache.name} = {cast}read_u{cache.size*16}(&this_instr[{offset}].cache);")
            offset += cache.size
        emit_tokens(out, uop, stack, inst)
        return offset
    except SizeMismatch as ex:
        raise analysis_error(ex, uop.body[0])

def uses_this(inst: Instruction) -> bool:
    if inst.properties.needs_this:
        return True
    for uop in inst.uops:
        if isinstance(uop, Skip):
            continue
        for cache in uop.caches:
            if cache.name != "unused":
                return True
    return False

def generate_tier1(filename: str, analysis: Analysis, outfile: TextIO) -> None:
    write_header(filename, outfile)
    out = CWriter(outfile, 2)
    out.emit("\n")
    for name, inst in sorted(analysis.instructions.items()):
        needs_this = uses_this(inst)
        out.emit(f"TARGET({name}) {{")
        if needs_this and not inst.is_target:
            out.emit(f"_Py_CODEUNIT *this_instr = frame->instr_ptr = next_instr;")
        else:
            out.emit(f"frame->instr_ptr = next_instr;")
        out.emit(f"next_instr += {inst.size};")
        out.emit(f"INSTRUCTION_STATS({name});")
        if inst.is_target:
            out.emit(f"PREDICTED({name});")
            if needs_this:
                out.emit(f"_Py_CODEUNIT *this_instr = next_instr - {inst.size};")
        #out.static_assert_family_size(mac.name, mac.family, mac.cache_offset)

        try:
            declare_variables(inst, out)
            offset = 1 # The instruction itself
            stack = Stack()
            for uop in inst.uops:
                offset = write_uop(uop, out, offset, stack, inst)
            stack.flush(out)
        except AssertionError as err:
            raise AssertionError(f"Error writing macro {name}") from err
        if not inst.uops[-1].properties.always_exits:
            if inst.uops[-1].properties.eval_breaker:
                out.emit("CHECK_EVAL_BREAKER();")
            out.emit("DISPATCH();")
        out.emit("}")
        out.emit("\n")
    outfile.write(FOOTER)


if __name__ == "__main__":
    import sys
    if len(sys.argv) < 2:
        print("No input")
    else:
        filename = sys.argv[1]
        data = analyze_file(filename)
        if sys.argv == 3:
            outfilename = sys.argv[2]
            with open(outfilename, "w") as outfile:
                generate_tier1(filename, data, out)
        else:
            generate_tier1(filename, data, sys.stdout)

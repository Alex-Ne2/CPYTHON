; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24210.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	inflate_fast
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflate_fast DD imagerel $LN107
	DD	imagerel $LN107+1244
	DD	imagerel $unwind$inflate_fast
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflate_fast DD 091501H
	DD	0f0116215H
	DD	0d00de00fH
	DD	07009c00bH
	DD	050076008H
	DD	03006H
; Function compile flags: /Ogtpy
; File c:\cpython\externals\zlib-1.2.11\inffast.c
;	COMDAT inflate_fast
_TEXT	SEGMENT
tv543 = 0
dcode$1$ = 8
window$1$ = 16
lcode$1$ = 24
beg$1$ = 32
strm$ = 128
wsize$1$ = 136
start$ = 136
tv542 = 144
whave$1$ = 152
inflate_fast PROC					; COMDAT

; 53   : {

$LN107:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	53		 push	 rbx
  00006	55		 push	 rbp
  00007	56		 push	 rsi
  00008	57		 push	 rdi
  00009	41 54		 push	 r12
  0000b	41 55		 push	 r13
  0000d	41 56		 push	 r14
  0000f	41 57		 push	 r15
  00011	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 54   :     struct inflate_state FAR *state;
; 55   :     z_const unsigned char FAR *in;      /* local strm->next_in */
; 56   :     z_const unsigned char FAR *last;    /* have enough input while in < last */
; 57   :     unsigned char FAR *out;     /* local strm->next_out */
; 58   :     unsigned char FAR *beg;     /* inflate()'s initial strm->next_out */
; 59   :     unsigned char FAR *end;     /* while out < end, enough space available */
; 60   : #ifdef INFLATE_STRICT
; 61   :     unsigned dmax;              /* maximum distance from zlib header */
; 62   : #endif
; 63   :     unsigned wsize;             /* window size or zero if not using window */
; 64   :     unsigned whave;             /* valid bytes in the window */
; 65   :     unsigned wnext;             /* window write index */
; 66   :     unsigned char FAR *window;  /* allocated sliding window, if wsize != 0 */
; 67   :     unsigned long hold;         /* local strm->hold */
; 68   :     unsigned bits;              /* local strm->bits */
; 69   :     code const FAR *lcode;      /* local strm->lencode */
; 70   :     code const FAR *dcode;      /* local strm->distcode */
; 71   :     unsigned lmask;             /* mask for first level of length codes */
; 72   :     unsigned dmask;             /* mask for first level of distance codes */
; 73   :     code here;                  /* retrieved table entry */
; 74   :     unsigned op;                /* code bits, operation, extra bits, or */
; 75   :                                 /*  window position, window bytes to copy */
; 76   :     unsigned len;               /* match length, unused bytes */
; 77   :     unsigned dist;              /* match distance */
; 78   :     unsigned char FAR *from;    /* where to copy match from */
; 79   : 
; 80   :     /* copy state to local variables */
; 81   :     state = (struct inflate_state FAR *)strm->state;

  00015	4c 8b 61 28	 mov	 r12, QWORD PTR [rcx+40]

; 82   :     in = strm->next_in;
; 83   :     last = in + (strm->avail_in - 5);
; 84   :     out = strm->next_out;
; 85   :     beg = out - (start - strm->avail_out);
; 86   :     end = out + (strm->avail_out - 257);
; 87   : #ifdef INFLATE_STRICT
; 88   :     dmax = state->dmax;
; 89   : #endif
; 90   :     wsize = state->wsize;
; 91   :     whave = state->whave;
; 92   :     wnext = state->wnext;
; 93   :     window = state->window;
; 94   :     hold = state->hold;
; 95   :     bits = state->bits;
; 96   :     lcode = state->lencode;
; 97   :     dcode = state->distcode;
; 98   :     lmask = (1U << state->lenbits) - 1;

  00019	bd 01 00 00 00	 mov	 ebp, 1
  0001e	44 8b 49 18	 mov	 r9d, DWORD PTR [rcx+24]
  00022	41 2b d1	 sub	 edx, r9d
  00025	44 8b 69 08	 mov	 r13d, DWORD PTR [rcx+8]
  00029	4c 8b 41 10	 mov	 r8, QWORD PTR [rcx+16]
  0002d	41 83 ed 05	 sub	 r13d, 5
  00031	48 8b 31	 mov	 rsi, QWORD PTR [rcx]
  00034	49 8b c8	 mov	 rcx, r8
  00037	49 8b 7c 24 68	 mov	 rdi, QWORD PTR [r12+104]
  0003c	45 8d b9 ff fe
	ff ff		 lea	 r15d, DWORD PTR [r9-257]
  00043	4d 8b 4c 24 60	 mov	 r9, QWORD PTR [r12+96]
  00048	4c 03 ee	 add	 r13, rsi
  0004b	45 8b 74 24 3c	 mov	 r14d, DWORD PTR [r12+60]
  00050	4d 03 f8	 add	 r15, r8
  00053	41 8b 5c 24 48	 mov	 ebx, DWORD PTR [r12+72]
  00058	45 8b 5c 24 4c	 mov	 r11d, DWORD PTR [r12+76]
  0005d	8b c2		 mov	 eax, edx
  0005f	8b d5		 mov	 edx, ebp
  00061	48 2b c8	 sub	 rcx, rax
  00064	4c 89 4c 24 18	 mov	 QWORD PTR lcode$1$[rsp], r9
  00069	41 8b 44 24 34	 mov	 eax, DWORD PTR [r12+52]
  0006e	89 84 24 88 00
	00 00		 mov	 DWORD PTR wsize$1$[rsp], eax
  00075	41 8b 44 24 38	 mov	 eax, DWORD PTR [r12+56]
  0007a	89 84 24 98 00
	00 00		 mov	 DWORD PTR whave$1$[rsp], eax
  00081	49 8b 44 24 40	 mov	 rax, QWORD PTR [r12+64]
  00086	48 89 44 24 10	 mov	 QWORD PTR window$1$[rsp], rax

; 99   :     dmask = (1U << state->distbits) - 1;

  0008b	8b c5		 mov	 eax, ebp
  0008d	48 89 4c 24 20	 mov	 QWORD PTR beg$1$[rsp], rcx
  00092	41 8b 4c 24 70	 mov	 ecx, DWORD PTR [r12+112]
  00097	d3 e2		 shl	 edx, cl
  00099	41 8b 4c 24 74	 mov	 ecx, DWORD PTR [r12+116]
  0009e	ff ca		 dec	 edx
  000a0	d3 e0		 shl	 eax, cl
  000a2	ff c8		 dec	 eax
  000a4	48 89 7c 24 08	 mov	 QWORD PTR dcode$1$[rsp], rdi
  000a9	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv542[rsp], eax
  000b0	89 14 24	 mov	 DWORD PTR tv543[rsp], edx
$LL4@inflate_fa:

; 100  : 
; 101  :     /* decode literals and length/distances until end-of-block or not enough
; 102  :        input data or output space */
; 103  :     do {
; 104  :         if (bits < 15) {

  000b3	41 83 fb 0f	 cmp	 r11d, 15
  000b7	73 1e		 jae	 SHORT $LN22@inflate_fa

; 105  :             hold += (unsigned long)(*in++) << bits;

  000b9	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  000bc	41 8b cb	 mov	 ecx, r11d
  000bf	d3 e0		 shl	 eax, cl

; 106  :             bits += 8;
; 107  :             hold += (unsigned long)(*in++) << bits;

  000c1	41 8d 4b 08	 lea	 ecx, DWORD PTR [r11+8]
  000c5	03 d8		 add	 ebx, eax
  000c7	0f b6 46 01	 movzx	 eax, BYTE PTR [rsi+1]
  000cb	d3 e0		 shl	 eax, cl
  000cd	48 83 c6 02	 add	 rsi, 2
  000d1	03 d8		 add	 ebx, eax

; 108  :             bits += 8;

  000d3	41 83 c3 10	 add	 r11d, 16
$LN22@inflate_fa:

; 109  :         }
; 110  :         here = lcode[hold & lmask];

  000d7	8b c3		 mov	 eax, ebx
  000d9	8b ca		 mov	 ecx, edx
  000db	48 23 c8	 and	 rcx, rax
  000de	45 8b 14 89	 mov	 r10d, DWORD PTR [r9+rcx*4]

; 111  :       dolen:
; 112  :         op = (unsigned)(here.bits);

  000e2	41 8b c2	 mov	 eax, r10d
  000e5	c1 e8 08	 shr	 eax, 8
  000e8	0f b6 c8	 movzx	 ecx, al

; 113  :         hold >>= op;

  000eb	d3 eb		 shr	 ebx, cl

; 114  :         bits -= op;

  000ed	44 2b d9	 sub	 r11d, ecx

; 115  :         op = (unsigned)(here.op);

  000f0	41 0f b6 d2	 movzx	 edx, r10b

; 116  :         if (op == 0) {                          /* literal */

  000f4	45 84 d2	 test	 r10b, r10b
  000f7	74 41		 je	 SHORT $LN72@inflate_fa
  000f9	0f 1f 80 00 00
	00 00		 npad	 7
$dolen$108:

; 121  :         }
; 122  :         else if (op & 16) {                     /* length base */

  00100	f6 c2 10	 test	 dl, 16
  00103	75 44		 jne	 SHORT $LN73@inflate_fa

; 274  :             }
; 275  :         }
; 276  :         else if ((op & 64) == 0) {              /* 2nd level length code */

  00105	f6 c2 40	 test	 dl, 64			; 00000040H
  00108	0f 85 1a 03 00
	00		 jne	 $LN52@inflate_fa

; 277  :             here = lcode[here.val + (hold & ((1U << op) - 1))];

  0010e	8b ca		 mov	 ecx, edx
  00110	41 c1 ea 10	 shr	 r10d, 16
  00114	8b c5		 mov	 eax, ebp
  00116	d3 e0		 shl	 eax, cl
  00118	ff c8		 dec	 eax
  0011a	23 c3		 and	 eax, ebx
  0011c	41 03 c2	 add	 eax, r10d
  0011f	45 8b 14 81	 mov	 r10d, DWORD PTR [r9+rax*4]
  00123	41 8b c2	 mov	 eax, r10d
  00126	c1 e8 08	 shr	 eax, 8
  00129	0f b6 c8	 movzx	 ecx, al
  0012c	d3 eb		 shr	 ebx, cl
  0012e	44 2b d9	 sub	 r11d, ecx
  00131	41 0f b6 d2	 movzx	 edx, r10b
  00135	45 84 d2	 test	 r10b, r10b
  00138	75 c6		 jne	 SHORT $dolen$108
$LN72@inflate_fa:

; 117  :             Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 118  :                     "inflate:         literal '%c'\n" :
; 119  :                     "inflate:         literal 0x%02x\n", here.val));
; 120  :             *out++ = (unsigned char)(here.val);

  0013a	41 c1 ea 10	 shr	 r10d, 16
  0013e	45 88 10	 mov	 BYTE PTR [r8], r10b
  00141	49 ff c0	 inc	 r8
  00144	e9 cd 02 00 00	 jmp	 $LN2@inflate_fa
$LN73@inflate_fa:

; 123  :             len = (unsigned)(here.val);

  00149	41 c1 ea 10	 shr	 r10d, 16

; 124  :             op &= 15;                           /* number of extra bits */

  0014d	83 e2 0f	 and	 edx, 15

; 125  :             if (op) {

  00150	74 28		 je	 SHORT $LN27@inflate_fa

; 126  :                 if (bits < op) {

  00152	44 3b da	 cmp	 r11d, edx
  00155	73 11		 jae	 SHORT $LN28@inflate_fa

; 127  :                     hold += (unsigned long)(*in++) << bits;

  00157	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  0015a	41 8b cb	 mov	 ecx, r11d
  0015d	d3 e0		 shl	 eax, cl
  0015f	48 ff c6	 inc	 rsi
  00162	03 d8		 add	 ebx, eax

; 128  :                     bits += 8;

  00164	41 83 c3 08	 add	 r11d, 8
$LN28@inflate_fa:

; 129  :                 }
; 130  :                 len += (unsigned)hold & ((1U << op) - 1);

  00168	8b ca		 mov	 ecx, edx
  0016a	8b c5		 mov	 eax, ebp
  0016c	d3 e0		 shl	 eax, cl
  0016e	ff c8		 dec	 eax
  00170	23 c3		 and	 eax, ebx

; 131  :                 hold >>= op;

  00172	d3 eb		 shr	 ebx, cl
  00174	44 03 d0	 add	 r10d, eax

; 132  :                 bits -= op;

  00177	44 2b da	 sub	 r11d, edx
$LN27@inflate_fa:

; 133  :             }
; 134  :             Tracevv((stderr, "inflate:         length %u\n", len));
; 135  :             if (bits < 15) {

  0017a	41 83 fb 0f	 cmp	 r11d, 15
  0017e	73 1e		 jae	 SHORT $LN29@inflate_fa

; 136  :                 hold += (unsigned long)(*in++) << bits;

  00180	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  00183	41 8b cb	 mov	 ecx, r11d
  00186	d3 e0		 shl	 eax, cl

; 137  :                 bits += 8;
; 138  :                 hold += (unsigned long)(*in++) << bits;

  00188	41 8d 4b 08	 lea	 ecx, DWORD PTR [r11+8]
  0018c	03 d8		 add	 ebx, eax
  0018e	0f b6 46 01	 movzx	 eax, BYTE PTR [rsi+1]
  00192	d3 e0		 shl	 eax, cl
  00194	48 83 c6 02	 add	 rsi, 2
  00198	03 d8		 add	 ebx, eax

; 139  :                 bits += 8;

  0019a	41 83 c3 10	 add	 r11d, 16
$LN29@inflate_fa:

; 140  :             }
; 141  :             here = dcode[hold & dmask];

  0019e	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv542[rsp]
  001a5	8b c3		 mov	 eax, ebx
  001a7	48 23 c8	 and	 rcx, rax
  001aa	8b 3c 8f	 mov	 edi, DWORD PTR [rdi+rcx*4]

; 142  :           dodist:
; 143  :             op = (unsigned)(here.bits);

  001ad	8b c7		 mov	 eax, edi
  001af	c1 e8 08	 shr	 eax, 8
  001b2	0f b6 c8	 movzx	 ecx, al

; 144  :             hold >>= op;

  001b5	d3 eb		 shr	 ebx, cl

; 145  :             bits -= op;

  001b7	44 2b d9	 sub	 r11d, ecx

; 146  :             op = (unsigned)(here.op);

  001ba	40 0f b6 d7	 movzx	 edx, dil

; 147  :             if (op & 16) {                      /* distance base */

  001be	f6 c2 10	 test	 dl, 16
  001c1	75 36		 jne	 SHORT $LN74@inflate_fa
$dodist$109:

; 263  :                     }
; 264  :                 }
; 265  :             }
; 266  :             else if ((op & 64) == 0) {          /* 2nd level distance code */

  001c3	f6 c2 40	 test	 dl, 64			; 00000040H
  001c6	0f 85 8a 02 00
	00		 jne	 $LN50@inflate_fa

; 267  :                 here = dcode[here.val + (hold & ((1U << op) - 1))];

  001cc	8b ca		 mov	 ecx, edx
  001ce	c1 ef 10	 shr	 edi, 16
  001d1	8b c5		 mov	 eax, ebp
  001d3	d3 e0		 shl	 eax, cl
  001d5	48 8b 4c 24 08	 mov	 rcx, QWORD PTR dcode$1$[rsp]
  001da	ff c8		 dec	 eax
  001dc	23 c3		 and	 eax, ebx
  001de	03 c7		 add	 eax, edi
  001e0	8b 3c 81	 mov	 edi, DWORD PTR [rcx+rax*4]
  001e3	8b c7		 mov	 eax, edi
  001e5	c1 e8 08	 shr	 eax, 8
  001e8	0f b6 c8	 movzx	 ecx, al
  001eb	d3 eb		 shr	 ebx, cl
  001ed	44 2b d9	 sub	 r11d, ecx
  001f0	40 0f b6 d7	 movzx	 edx, dil
  001f4	f6 c2 10	 test	 dl, 16
  001f7	74 ca		 je	 SHORT $dodist$109
$LN74@inflate_fa:

; 148  :                 dist = (unsigned)(here.val);

  001f9	c1 ef 10	 shr	 edi, 16

; 149  :                 op &= 15;                       /* number of extra bits */

  001fc	83 e2 0f	 and	 edx, 15

; 150  :                 if (bits < op) {

  001ff	44 3b da	 cmp	 r11d, edx
  00202	73 27		 jae	 SHORT $LN33@inflate_fa

; 151  :                     hold += (unsigned long)(*in++) << bits;

  00204	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  00207	41 8b cb	 mov	 ecx, r11d
  0020a	d3 e0		 shl	 eax, cl
  0020c	48 ff c6	 inc	 rsi
  0020f	03 d8		 add	 ebx, eax

; 152  :                     bits += 8;

  00211	41 83 c3 08	 add	 r11d, 8

; 153  :                     if (bits < op) {

  00215	44 3b da	 cmp	 r11d, edx
  00218	73 11		 jae	 SHORT $LN33@inflate_fa

; 154  :                         hold += (unsigned long)(*in++) << bits;

  0021a	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  0021d	41 8b cb	 mov	 ecx, r11d
  00220	d3 e0		 shl	 eax, cl
  00222	48 ff c6	 inc	 rsi
  00225	03 d8		 add	 ebx, eax

; 155  :                         bits += 8;

  00227	41 83 c3 08	 add	 r11d, 8
$LN33@inflate_fa:

; 156  :                     }
; 157  :                 }
; 158  :                 dist += (unsigned)hold & ((1U << op) - 1);

  0022b	8b ca		 mov	 ecx, edx
  0022d	8b c5		 mov	 eax, ebp
  0022f	d3 e0		 shl	 eax, cl

; 159  : #ifdef INFLATE_STRICT
; 160  :                 if (dist > dmax) {
; 161  :                     strm->msg = (char *)"invalid distance too far back";
; 162  :                     state->mode = BAD;
; 163  :                     break;
; 164  :                 }
; 165  : #endif
; 166  :                 hold >>= op;
; 167  :                 bits -= op;

  00231	44 2b da	 sub	 r11d, edx
  00234	ff c8		 dec	 eax
  00236	23 c3		 and	 eax, ebx
  00238	d3 eb		 shr	 ebx, cl
  0023a	03 f8		 add	 edi, eax

; 168  :                 Tracevv((stderr, "inflate:         distance %u\n", dist));
; 169  :                 op = (unsigned)(out - beg);     /* max distance in output */

  0023c	41 8b c0	 mov	 eax, r8d
  0023f	2b 44 24 20	 sub	 eax, DWORD PTR beg$1$[rsp]

; 170  :                 if (dist > op) {                /* see if copy from window */

  00243	3b f8		 cmp	 edi, eax
  00245	0f 86 6a 01 00
	00		 jbe	 $LN34@inflate_fa

; 171  :                     op = dist - op;             /* distance back in window */

  0024b	8b cf		 mov	 ecx, edi
  0024d	2b c8		 sub	 ecx, eax

; 172  :                     if (op > whave) {

  0024f	3b 8c 24 98 00
	00 00		 cmp	 ecx, DWORD PTR whave$1$[rsp]
  00256	76 0f		 jbe	 SHORT $LN37@inflate_fa

; 173  :                         if (state->sane) {

  00258	41 83 bc 24 e0
	1b 00 00 00	 cmp	 DWORD PTR [r12+7136], 0
  00261	0f 85 0d 02 00
	00		 jne	 $LN75@inflate_fa
$LN37@inflate_fa:

; 177  :                             break;
; 178  :                         }
; 179  : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 180  :                         if (len <= op - whave) {
; 181  :                             do {
; 182  :                                 *out++ = 0;
; 183  :                             } while (--len);
; 184  :                             continue;
; 185  :                         }
; 186  :                         len -= op - whave;
; 187  :                         do {
; 188  :                             *out++ = 0;
; 189  :                         } while (--op > whave);
; 190  :                         if (op == 0) {
; 191  :                             from = out - dist;
; 192  :                             do {
; 193  :                                 *out++ = *from++;
; 194  :                             } while (--len);
; 195  :                             continue;
; 196  :                         }
; 197  : #endif
; 198  :                     }
; 199  :                     from = window;
; 200  :                     if (wnext == 0) {           /* very common case */

  00267	45 85 f6	 test	 r14d, r14d
  0026a	75 3c		 jne	 SHORT $LN38@inflate_fa

; 201  :                         from += wsize - op;

  0026c	44 8b 8c 24 88
	00 00 00	 mov	 r9d, DWORD PTR wsize$1$[rsp]
  00274	44 2b c9	 sub	 r9d, ecx
  00277	4c 03 4c 24 10	 add	 r9, QWORD PTR window$1$[rsp]

; 202  :                         if (op < len) {         /* some from window */

  0027c	41 3b ca	 cmp	 ecx, r10d
  0027f	0f 83 b8 00 00
	00		 jae	 $LN69@inflate_fa

; 203  :                             len -= op;

  00285	44 2b d1	 sub	 r10d, ecx
  00288	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL7@inflate_fa:

; 204  :                             do {
; 205  :                                 *out++ = *from++;

  00290	41 0f b6 01	 movzx	 eax, BYTE PTR [r9]
  00294	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]
  00298	41 88 00	 mov	 BYTE PTR [r8], al
  0029b	49 ff c0	 inc	 r8

; 206  :                             } while (--op);

  0029e	83 c1 ff	 add	 ecx, -1			; ffffffffH
  002a1	75 ed		 jne	 SHORT $LL7@inflate_fa

; 207  :                             from = out - dist;  /* rest from output */
; 208  :                         }
; 209  :                     }

  002a3	e9 8d 00 00 00	 jmp	 $LN104@inflate_fa
$LN38@inflate_fa:

; 210  :                     else if (wnext < op) {      /* wrap around window */
; 211  :                         from += wsize + wnext - op;

  002a8	45 8b ce	 mov	 r9d, r14d
  002ab	44 2b c9	 sub	 r9d, ecx
  002ae	44 3b f1	 cmp	 r14d, ecx
  002b1	73 62		 jae	 SHORT $LN41@inflate_fa
  002b3	44 03 8c 24 88
	00 00 00	 add	 r9d, DWORD PTR wsize$1$[rsp]

; 212  :                         op -= wnext;

  002bb	41 2b ce	 sub	 ecx, r14d
  002be	48 8b 54 24 10	 mov	 rdx, QWORD PTR window$1$[rsp]
  002c3	4c 03 ca	 add	 r9, rdx

; 213  :                         if (op < len) {         /* some from end of window */

  002c6	41 3b ca	 cmp	 ecx, r10d
  002c9	73 72		 jae	 SHORT $LN69@inflate_fa

; 214  :                             len -= op;

  002cb	44 2b d1	 sub	 r10d, ecx

; 217  :                             } while (--op);

  002ce	4d 2b c8	 sub	 r9, r8
  002d1	0f 1f 40 00 66
	66 66 0f 1f 84
	00 00 00 00 00	 npad	 15
$LL10@inflate_fa:

; 215  :                             do {
; 216  :                                 *out++ = *from++;

  002e0	43 0f b6 04 01	 movzx	 eax, BYTE PTR [r9+r8]
  002e5	41 88 00	 mov	 BYTE PTR [r8], al
  002e8	49 ff c0	 inc	 r8

; 217  :                             } while (--op);

  002eb	83 c1 ff	 add	 ecx, -1			; ffffffffH
  002ee	75 f0		 jne	 SHORT $LL10@inflate_fa

; 218  :                             from = window;

  002f0	4c 8b ca	 mov	 r9, rdx

; 219  :                             if (wnext < len) {  /* some from start of window */

  002f3	45 3b f2	 cmp	 r14d, r10d
  002f6	73 45		 jae	 SHORT $LN69@inflate_fa

; 220  :                                 op = wnext;

  002f8	41 8b ce	 mov	 ecx, r14d

; 221  :                                 len -= op;

  002fb	45 2b d6	 sub	 r10d, r14d
  002fe	66 90		 npad	 2
$LL13@inflate_fa:

; 222  :                                 do {
; 223  :                                     *out++ = *from++;

  00300	41 0f b6 01	 movzx	 eax, BYTE PTR [r9]
  00304	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]
  00308	41 88 00	 mov	 BYTE PTR [r8], al
  0030b	49 ff c0	 inc	 r8

; 224  :                                 } while (--op);

  0030e	83 c1 ff	 add	 ecx, -1			; ffffffffH
  00311	75 ed		 jne	 SHORT $LL13@inflate_fa

; 225  :                                 from = out - dist;      /* rest from output */
; 226  :                             }
; 227  :                         }
; 228  :                     }

  00313	eb 20		 jmp	 SHORT $LN104@inflate_fa
$LN41@inflate_fa:

; 229  :                     else {                      /* contiguous in window */
; 230  :                         from += wnext - op;

  00315	4c 03 4c 24 10	 add	 r9, QWORD PTR window$1$[rsp]

; 231  :                         if (op < len) {         /* some from window */

  0031a	41 3b ca	 cmp	 ecx, r10d
  0031d	73 1e		 jae	 SHORT $LN69@inflate_fa

; 232  :                             len -= op;

  0031f	44 2b d1	 sub	 r10d, ecx
$LL16@inflate_fa:

; 233  :                             do {
; 234  :                                 *out++ = *from++;

  00322	41 0f b6 01	 movzx	 eax, BYTE PTR [r9]
  00326	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]
  0032a	41 88 00	 mov	 BYTE PTR [r8], al
  0032d	49 ff c0	 inc	 r8

; 235  :                             } while (--op);

  00330	83 c1 ff	 add	 ecx, -1			; ffffffffH
  00333	75 ed		 jne	 SHORT $LL16@inflate_fa
$LN104@inflate_fa:

; 236  :                             from = out - dist;  /* rest from output */

  00335	8b c7		 mov	 eax, edi
  00337	4d 8b c8	 mov	 r9, r8
  0033a	4c 2b c8	 sub	 r9, rax
$LN69@inflate_fa:

; 237  :                         }
; 238  :                     }
; 239  :                     while (len > 2) {

  0033d	41 83 fa 02	 cmp	 r10d, 2
  00341	76 47		 jbe	 SHORT $LN18@inflate_fa
  00343	41 8d 4a fd	 lea	 ecx, DWORD PTR [r10-3]
  00347	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  0034c	f7 e1		 mul	 ecx
  0034e	d1 ea		 shr	 edx, 1
  00350	8d 4a 01	 lea	 ecx, DWORD PTR [rdx+1]
  00353	0f 1f 40 00 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL17@inflate_fa:

; 240  :                         *out++ = *from++;

  00360	41 0f b6 01	 movzx	 eax, BYTE PTR [r9]

; 241  :                         *out++ = *from++;
; 242  :                         *out++ = *from++;
; 243  :                         len -= 3;

  00364	41 83 c2 fd	 add	 r10d, -3		; fffffffdH
  00368	41 88 00	 mov	 BYTE PTR [r8], al
  0036b	41 0f b6 41 01	 movzx	 eax, BYTE PTR [r9+1]
  00370	41 88 40 01	 mov	 BYTE PTR [r8+1], al
  00374	41 0f b6 41 02	 movzx	 eax, BYTE PTR [r9+2]
  00379	49 83 c1 03	 add	 r9, 3
  0037d	41 88 40 02	 mov	 BYTE PTR [r8+2], al
  00381	49 83 c0 03	 add	 r8, 3
  00385	48 2b cd	 sub	 rcx, rbp
  00388	75 d6		 jne	 SHORT $LL17@inflate_fa
$LN18@inflate_fa:

; 244  :                     }
; 245  :                     if (len) {

  0038a	45 85 d2	 test	 r10d, r10d
  0038d	74 7d		 je	 SHORT $LN98@inflate_fa

; 246  :                         *out++ = *from++;

  0038f	41 0f b6 01	 movzx	 eax, BYTE PTR [r9]

; 249  :                     }
; 250  :                 }

  00393	48 8b 7c 24 08	 mov	 rdi, QWORD PTR dcode$1$[rsp]
  00398	41 88 00	 mov	 BYTE PTR [r8], al
  0039b	49 ff c0	 inc	 r8
  0039e	44 3b d5	 cmp	 r10d, ebp
  003a1	76 0b		 jbe	 SHORT $LN99@inflate_fa

; 247  :                         if (len > 1)
; 248  :                             *out++ = *from++;

  003a3	41 0f b6 41 01	 movzx	 eax, BYTE PTR [r9+1]
  003a8	41 88 00	 mov	 BYTE PTR [r8], al
  003ab	49 ff c0	 inc	 r8
$LN99@inflate_fa:

; 249  :                     }
; 250  :                 }

  003ae	4c 8b 4c 24 18	 mov	 r9, QWORD PTR lcode$1$[rsp]
  003b3	eb 61		 jmp	 SHORT $LN2@inflate_fa
$LN34@inflate_fa:

; 251  :                 else {
; 252  :                     from = out - dist;          /* copy direct from output */

  003b5	8b c7		 mov	 eax, edi
  003b7	49 8b c8	 mov	 rcx, r8
  003ba	48 2b c8	 sub	 rcx, rax
  003bd	0f 1f 00	 npad	 3
$LL21@inflate_fa:

; 253  :                     do {                        /* minimum length is three */
; 254  :                         *out++ = *from++;

  003c0	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 255  :                         *out++ = *from++;
; 256  :                         *out++ = *from++;

  003c3	48 8d 49 03	 lea	 rcx, QWORD PTR [rcx+3]
  003c7	41 88 00	 mov	 BYTE PTR [r8], al

; 257  :                         len -= 3;

  003ca	41 83 c2 fd	 add	 r10d, -3		; fffffffdH
  003ce	0f b6 41 fe	 movzx	 eax, BYTE PTR [rcx-2]
  003d2	41 88 40 01	 mov	 BYTE PTR [r8+1], al
  003d6	0f b6 41 ff	 movzx	 eax, BYTE PTR [rcx-1]
  003da	41 88 40 02	 mov	 BYTE PTR [r8+2], al
  003de	49 83 c0 03	 add	 r8, 3

; 258  :                     } while (len > 2);

  003e2	41 83 fa 02	 cmp	 r10d, 2
  003e6	77 d8		 ja	 SHORT $LL21@inflate_fa

; 259  :                     if (len) {

  003e8	45 85 d2	 test	 r10d, r10d
  003eb	74 24		 je	 SHORT $LN103@inflate_fa

; 260  :                         *out++ = *from++;

  003ed	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 261  :                         if (len > 1)
; 262  :                             *out++ = *from++;

  003f0	48 8b 7c 24 08	 mov	 rdi, QWORD PTR dcode$1$[rsp]
  003f5	41 88 00	 mov	 BYTE PTR [r8], al
  003f8	49 ff c0	 inc	 r8
  003fb	44 3b d5	 cmp	 r10d, ebp
  003fe	76 16		 jbe	 SHORT $LN2@inflate_fa
  00400	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00404	41 88 00	 mov	 BYTE PTR [r8], al
  00407	49 ff c0	 inc	 r8
  0040a	eb 0a		 jmp	 SHORT $LN2@inflate_fa
$LN98@inflate_fa:
  0040c	4c 8b 4c 24 18	 mov	 r9, QWORD PTR lcode$1$[rsp]
$LN103@inflate_fa:
  00411	48 8b 7c 24 08	 mov	 rdi, QWORD PTR dcode$1$[rsp]
$LN2@inflate_fa:

; 288  :             break;
; 289  :         }
; 290  :     } while (in < last && out < end);

  00416	49 3b f5	 cmp	 rsi, r13
  00419	73 62		 jae	 SHORT $LN101@inflate_fa
  0041b	4d 3b c7	 cmp	 r8, r15
  0041e	73 5d		 jae	 SHORT $LN101@inflate_fa
  00420	8b 14 24	 mov	 edx, DWORD PTR tv543[rsp]
  00423	e9 8b fc ff ff	 jmp	 $LL4@inflate_fa
$LN52@inflate_fa:

; 283  :             break;

  00428	48 8b bc 24 80
	00 00 00	 mov	 rdi, QWORD PTR strm$[rsp]
  00430	f6 c2 20	 test	 dl, 32			; 00000020H
  00433	74 0b		 je	 SHORT $LN54@inflate_fa

; 278  :             goto dolen;
; 279  :         }
; 280  :         else if (op & 32) {                     /* end-of-block */
; 281  :             Tracevv((stderr, "inflate:         end of block\n"));
; 282  :             state->mode = TYPE;

  00435	41 c7 44 24 08
	3f 3f 00 00	 mov	 DWORD PTR [r12+8], 16191 ; 00003f3fH

; 283  :             break;

  0043e	eb 45		 jmp	 SHORT $LN3@inflate_fa
$LN54@inflate_fa:

; 284  :         }
; 285  :         else {
; 286  :             strm->msg = (char *)"invalid literal/length code";

  00440	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@
  00447	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax

; 287  :             state->mode = BAD;

  0044b	41 c7 44 24 08
	51 3f 00 00	 mov	 DWORD PTR [r12+8], 16209 ; 00003f51H
  00454	eb 2f		 jmp	 SHORT $LN3@inflate_fa
$LN50@inflate_fa:

; 268  :                 goto dodist;
; 269  :             }
; 270  :             else {
; 271  :                 strm->msg = (char *)"invalid distance code";

  00456	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@
$LN105@inflate_fa:
  0045d	48 8b bc 24 80
	00 00 00	 mov	 rdi, QWORD PTR strm$[rsp]
  00465	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax

; 272  :                 state->mode = BAD;

  00469	41 c7 44 24 08
	51 3f 00 00	 mov	 DWORD PTR [r12+8], 16209 ; 00003f51H

; 273  :                 break;

  00472	eb 11		 jmp	 SHORT $LN3@inflate_fa
$LN75@inflate_fa:

; 174  :                             strm->msg =

  00474	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@

; 175  :                                 (char *)"invalid distance too far back";
; 176  :                             state->mode = BAD;

  0047b	eb e0		 jmp	 SHORT $LN105@inflate_fa
$LN101@inflate_fa:
  0047d	48 8b bc 24 80
	00 00 00	 mov	 rdi, QWORD PTR strm$[rsp]
$LN3@inflate_fa:

; 291  : 
; 292  :     /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
; 293  :     len = bits >> 3;

  00485	41 8b cb	 mov	 ecx, r11d

; 294  :     in -= len;
; 295  :     bits -= len << 3;
; 296  :     hold &= (1U << bits) - 1;
; 297  : 
; 298  :     /* update state and return */
; 299  :     strm->next_in = in;
; 300  :     strm->next_out = out;

  00488	4c 89 47 10	 mov	 QWORD PTR [rdi+16], r8
  0048c	c1 e9 03	 shr	 ecx, 3
  0048f	8b c1		 mov	 eax, ecx
  00491	48 2b f0	 sub	 rsi, rax

; 301  :     strm->avail_in = (unsigned)(in < last ? 5 + (last - in) : 5 - (in - last));

  00494	4c 2b ee	 sub	 r13, rsi
  00497	48 89 37	 mov	 QWORD PTR [rdi], rsi
  0049a	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [rcx*8]
  004a1	44 2b d8	 sub	 r11d, eax
  004a4	41 8b cb	 mov	 ecx, r11d
  004a7	d3 e5		 shl	 ebp, cl
  004a9	49 8d 45 05	 lea	 rax, QWORD PTR [r13+5]
  004ad	89 47 08	 mov	 DWORD PTR [rdi+8], eax
  004b0	ff cd		 dec	 ebp
  004b2	23 dd		 and	 ebx, ebp

; 302  :     strm->avail_out = (unsigned)(out < end ?

  004b4	4d 2b f8	 sub	 r15, r8
  004b7	49 8d 87 01 01
	00 00		 lea	 rax, QWORD PTR [r15+257]
  004be	89 47 18	 mov	 DWORD PTR [rdi+24], eax

; 303  :                                  257 + (end - out) : 257 - (out - end));
; 304  :     state->hold = hold;

  004c1	41 89 5c 24 48	 mov	 DWORD PTR [r12+72], ebx

; 305  :     state->bits = bits;

  004c6	45 89 5c 24 4c	 mov	 DWORD PTR [r12+76], r11d

; 306  :     return;
; 307  : }

  004cb	48 83 c4 38	 add	 rsp, 56			; 00000038H
  004cf	41 5f		 pop	 r15
  004d1	41 5e		 pop	 r14
  004d3	41 5d		 pop	 r13
  004d5	41 5c		 pop	 r12
  004d7	5f		 pop	 rdi
  004d8	5e		 pop	 rsi
  004d9	5d		 pop	 rbp
  004da	5b		 pop	 rbx
  004db	c3		 ret	 0
inflate_fast ENDP
_TEXT	ENDS
END

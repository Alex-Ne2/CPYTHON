// This file is generated by Tools/cases_generator/generate_cases.py
// from:
//   Python/bytecodes.c
// Do not edit!

        case NOP: {
            break;
        }

        case LOAD_FAST: {
            PyObject *value;
            value = GETLOCAL(oparg);
            assert(value != NULL);
            Py_INCREF(value);
            STACK_GROW(1);
            stack_pointer[-1] = value;
            break;
        }

        case LOAD_FAST_AND_CLEAR: {
            PyObject *value;
            value = GETLOCAL(oparg);
            // do not use SETLOCAL here, it decrefs the old value
            GETLOCAL(oparg) = NULL;
            STACK_GROW(1);
            stack_pointer[-1] = value;
            break;
        }

        case LOAD_CONST: {
            PyObject *value;
            value = GETITEM(FRAME_CO_CONSTS, oparg);
            Py_INCREF(value);
            STACK_GROW(1);
            stack_pointer[-1] = value;
            break;
        }

        case STORE_FAST: {
            PyObject *value = stack_pointer[-1];
            SETLOCAL(oparg, value);
            STACK_SHRINK(1);
            break;
        }

        case POP_TOP: {
            PyObject *value = stack_pointer[-1];
            Py_DECREF(value);
            STACK_SHRINK(1);
            break;
        }

        case PUSH_NULL: {
            PyObject *res;
            res = NULL;
            STACK_GROW(1);
            stack_pointer[-1] = res;
            break;
        }

        case END_SEND: {
            PyObject *value = stack_pointer[-1];
            PyObject *receiver = stack_pointer[-2];
            Py_DECREF(receiver);
            STACK_SHRINK(1);
            stack_pointer[-1] = value;
            break;
        }

        case _BINARY_OP_MULTIPLY_FLOAT: {
            PyObject *right = stack_pointer[-1];
            PyObject *left = stack_pointer[-2];
            PyObject *res;
            STAT_INC(BINARY_OP, hit);
            double dres =
                ((PyFloatObject *)left)->ob_fval *
                ((PyFloatObject *)right)->ob_fval;
            DECREF_INPUTS_AND_REUSE_FLOAT(left, right, dres, res);
            STACK_SHRINK(1);
            stack_pointer[-1] = res;
            break;
        }

        case _BINARY_OP_ADD_FLOAT: {
            PyObject *right = stack_pointer[-1];
            PyObject *left = stack_pointer[-2];
            PyObject *res;
            STAT_INC(BINARY_OP, hit);
            double dres =
                ((PyFloatObject *)left)->ob_fval +
                ((PyFloatObject *)right)->ob_fval;
            DECREF_INPUTS_AND_REUSE_FLOAT(left, right, dres, res);
            STACK_SHRINK(1);
            stack_pointer[-1] = res;
            break;
        }

        case _BINARY_OP_SUBTRACT_FLOAT: {
            PyObject *right = stack_pointer[-1];
            PyObject *left = stack_pointer[-2];
            PyObject *res;
            STAT_INC(BINARY_OP, hit);
            double dres =
                ((PyFloatObject *)left)->ob_fval -
                ((PyFloatObject *)right)->ob_fval;
            DECREF_INPUTS_AND_REUSE_FLOAT(left, right, dres, res);
            STACK_SHRINK(1);
            stack_pointer[-1] = res;
            break;
        }

        case STORE_SUBSCR: {
            static_assert(INLINE_CACHE_ENTRIES_STORE_SUBSCR == 1, "incorrect cache size");
            PyObject *sub = stack_pointer[-1];
            PyObject *container = stack_pointer[-2];
            PyObject *v = stack_pointer[-3];
            uint16_t counter = oparg;
            #if ENABLE_SPECIALIZATION
            if (ADAPTIVE_COUNTER_IS_ZERO(counter)) {
                next_instr--;
                _Py_Specialize_StoreSubscr(container, sub, next_instr);
                DISPATCH_SAME_OPARG();
            }
            STAT_INC(STORE_SUBSCR, deferred);
            _PyStoreSubscrCache *cache = (_PyStoreSubscrCache *)next_instr;
            DECREMENT_ADAPTIVE_COUNTER(cache->counter);
            #else
            (void)counter;  // Unused.
            #endif  /* ENABLE_SPECIALIZATION */
            /* container[sub] = v */
            int err = PyObject_SetItem(container, sub, v);
            Py_DECREF(v);
            Py_DECREF(container);
            Py_DECREF(sub);
            if (err) goto pop_3_error;
            STACK_SHRINK(3);
            break;
        }

        case LOAD_ASSERTION_ERROR: {
            PyObject *value;
            value = Py_NewRef(PyExc_AssertionError);
            STACK_GROW(1);
            stack_pointer[-1] = value;
            break;
        }

        case STORE_DEREF: {
            PyObject *v = stack_pointer[-1];
            PyObject *cell = GETLOCAL(oparg);
            PyObject *oldobj = PyCell_GET(cell);
            PyCell_SET(cell, v);
            Py_XDECREF(oldobj);
            STACK_SHRINK(1);
            break;
        }

        case COPY_FREE_VARS: {
            /* Copy closure variables to free variables */
            PyCodeObject *co = _PyFrame_GetCode(frame);
            assert(PyFunction_Check(frame->f_funcobj));
            PyObject *closure = ((PyFunctionObject *)frame->f_funcobj)->func_closure;
            assert(oparg == co->co_nfreevars);
            int offset = co->co_nlocalsplus - oparg;
            for (int i = 0; i < oparg; ++i) {
                PyObject *o = PyTuple_GET_ITEM(closure, i);
                frame->localsplus[offset + i] = Py_NewRef(o);
            }
            break;
        }

        case IS_OP: {
            PyObject *right = stack_pointer[-1];
            PyObject *left = stack_pointer[-2];
            PyObject *b;
            int res = Py_Is(left, right) ^ oparg;
            Py_DECREF(left);
            Py_DECREF(right);
            b = res ? Py_True : Py_False;
            STACK_SHRINK(1);
            stack_pointer[-1] = b;
            break;
        }

        case MATCH_MAPPING: {
            PyObject *subject = stack_pointer[-1];
            PyObject *res;
            int match = Py_TYPE(subject)->tp_flags & Py_TPFLAGS_MAPPING;
            res = match ? Py_True : Py_False;
            STACK_GROW(1);
            stack_pointer[-1] = res;
            break;
        }

        case MATCH_SEQUENCE: {
            PyObject *subject = stack_pointer[-1];
            PyObject *res;
            int match = Py_TYPE(subject)->tp_flags & Py_TPFLAGS_SEQUENCE;
            res = match ? Py_True : Py_False;
            STACK_GROW(1);
            stack_pointer[-1] = res;
            break;
        }

        case COPY: {
            PyObject *bottom = stack_pointer[-(1 + (oparg-1))];
            PyObject *top;
            assert(oparg > 0);
            top = Py_NewRef(bottom);
            STACK_GROW(1);
            stack_pointer[-1] = top;
            break;
        }

        case SWAP: {
            PyObject *top = stack_pointer[-1];
            PyObject *bottom = stack_pointer[-(2 + (oparg-2))];
            assert(oparg >= 2);
            stack_pointer[-1] = bottom;
            stack_pointer[-(2 + (oparg-2))] = top;
            break;
        }

#include "Python.h"
#include "Python-ast.h"


/* TODO: is_const and get_const_value is copied from Python/compile.c.
   It should be deduped in the future.  Maybe, we can include this file
   from compile.c?
*/
static int
is_const(expr_ty e)
{
    switch (e->kind) {
    case Constant_kind:
    case Num_kind:
    case Str_kind:
    case Bytes_kind:
    case Ellipsis_kind:
    case NameConstant_kind:
        return 1;
    default:
        return 0;
    }
}

static PyObject *
get_const_value(expr_ty e)
{
    switch (e->kind) {
    case Constant_kind:
        return e->v.Constant.value;
    case Num_kind:
        return e->v.Num.n;
    case Str_kind:
        return e->v.Str.s;
    case Bytes_kind:
        return e->v.Bytes.s;
    case Ellipsis_kind:
        return Py_Ellipsis;
    case NameConstant_kind:
        return e->v.NameConstant.value;
    default:
        assert(!is_const(e));
        return NULL;
    }
}

static int make_const(expr_ty node, PyObject *val, PyArena *arena)
{
    if (val == NULL) {
        if(!PyErr_ExceptionMatches(PyExc_KeyboardInterrupt))
            PyErr_Clear();
        return 1;
    }
    if (PyArena_AddPyObject(arena, val) < 0) {
        Py_DECREF(val);
        return 0;
    }
    node->kind = Constant_kind;
    node->v.Constant.value = val;
    return 1;
}

#define COPY_NODE(TO, FROM) (memcpy((TO), (FROM), sizeof(struct _expr)))

static PyObject *unary_not(PyObject *v)
{
    int r = PyObject_IsTrue(v);
    if (r < 0)
        return NULL;
    return PyBool_FromLong(!r);
}

@post(astfold, UnaryOp, fold_unaryop)
static int fold_unaryop(expr_ty node, PyArena *arena)
{
    expr_ty arg = node->v.UnaryOp.operand;

    if (!is_const(arg)) {
        /* Fold not into comparison */
        if (node->v.UnaryOp.op == Not && arg->kind == Compare_kind &&
                asdl_seq_LEN(arg->v.Compare.ops) == 1) {
            /* Eq and NotEq are often implemented in terms of one another, so
               folding not (self == other) into self != other breaks implementation
               of !=. Detecting such cases doesn't seem worthwhile.
               Python uses </> for 'is subset'/'is superset' operations on sets.
               They don't satisfy not folding laws. */
            int op = asdl_seq_GET(arg->v.Compare.ops, 0);
            switch (op) {
            case Is:
                op = IsNot;
                break;
            case IsNot:
                op = Is;
                break;
            case In:
                op = NotIn;
                break;
            case NotIn:
                op = In;
                break;
            default:
                op = 0;
            }
            if (op) {
                asdl_seq_SET(arg->v.Compare.ops, 0, op);
                COPY_NODE(node, arg);
                return 1;
            }
        }
        return 1;
    }

    typedef PyObject *(*unary_op)(PyObject*);
    static const unary_op ops[] = {
        0,
        PyNumber_Invert,
        unary_not,
        PyNumber_Positive,
        PyNumber_Negative
    };
    PyObject *newval = ops[node->v.UnaryOp.op](get_const_value(arg));
    return make_const(node, newval, arena);
}

@post(astfold, BinOp, fold_binop)
static int fold_binop(expr_ty node, PyArena *arena)
{
    expr_ty lhs, rhs;
    lhs = node->v.BinOp.left;
    rhs = node->v.BinOp.right;
    if (!is_const(lhs) || !is_const(rhs)) {
        return 1;
    }

    PyObject *lv = get_const_value(lhs);
    PyObject *rv = get_const_value(rhs);
    PyObject *newval;

    switch (node->v.BinOp.op) {
    case Add:
        newval = PyNumber_Add(lv, rv);
        break;
    case Sub:
        newval = PyNumber_Subtract(lv, rv);
        break;
    case Mult:
        newval = PyNumber_Multiply(lv, rv);
        break;
    case Div:
        newval = PyNumber_TrueDivide(lv, rv);
        break;
    case FloorDiv:
        newval = PyNumber_FloorDivide(lv, rv);
        break;
    case Mod:
        newval = PyNumber_Remainder(lv, rv);
        break;
    case Pow:
        newval = PyNumber_Power(lv, rv, Py_None);
        break;
    case LShift:
        newval = PyNumber_Lshift(lv, rv);
        break;
    case RShift:
        newval = PyNumber_Rshift(lv, rv);
        break;
    case BitOr:
        newval = PyNumber_Or(lv, rv);
        break;
    case BitXor:
        newval = PyNumber_Xor(lv, rv);
        break;
    case BitAnd:
        newval = PyNumber_And(lv, rv);
        break;
    default: // Unknown operator
        return 1;
    }

    /* Avoid creating large constants. */
    Py_ssize_t size = PyObject_Size(newval);
    if (size == -1) {
        if (PyErr_ExceptionMatches(PyExc_KeyboardInterrupt))
            return 1;
        PyErr_Clear();
    }
    else if (size > 20) {
        Py_DECREF(newval);
        return 1;
    }
    return make_const(node, newval, arena);
}

static PyObject *make_const_tuple(asdl_seq *elts, int make_set)
{
    for (int i = 0; i < asdl_seq_LEN(elts); i++) {
        expr_ty e = (expr_ty)asdl_seq_GET(elts, i);
        if (!is_const(e)) {
            return NULL;
        }
    }

    PyObject *newval = PyTuple_New(asdl_seq_LEN(elts));
    if (newval == NULL) {
        return NULL;
    }

    for (int i = 0; i < asdl_seq_LEN(elts); i++) {
        expr_ty e = (expr_ty)asdl_seq_GET(elts, i);
        PyObject *v = get_const_value(e);
        Py_INCREF(v);
        PyTuple_SET_ITEM(newval, i, v);
    }

    /* Need to create frozen_set instead. */
    if (make_set) {
        Py_SETREF(newval, PyFrozenSet_New(newval));
    }
    return newval;
}

@post(astfold, Tuple, fold_tuple)
static int fold_tuple(expr_ty node, PyArena *arena)
{
    PyObject *newval;

    if (node->v.Tuple.ctx != Load)
        return 1;

    newval = make_const_tuple(node->v.Tuple.elts, 0);
    return make_const(node, newval, arena);
}

@post(astfold, Subscript, fold_subscr)
static int fold_subscr(expr_ty node, PyArena *arena)
{
    PyObject *newval;
    expr_ty arg, idx;
    slice_ty slice;

    arg = node->v.Subscript.value;
    slice = node->v.Subscript.slice;
    if (node->v.Subscript.ctx != Load ||
            !is_const(arg) ||
            /* TODO: handle other types of slices */
            slice->kind != Index_kind ||
            !is_const(slice->v.Index.value)) {
        return 1;
    }

    idx = slice->v.Index.value;
    newval = PyObject_GetItem(get_const_value(arg), get_const_value(idx));
    return make_const(node, newval, arena);
}

@post(astfold, Compare, fold_compare)
static int fold_compare(expr_ty node, PyArena *arena)
{
    asdl_int_seq *ops;
    asdl_seq *args;
    PyObject *newval;
    int i;

    ops = node->v.Compare.ops;
    args = node->v.Compare.comparators;
    /* TODO: optimize cases with literal arguments. */
    for (i = 0; i < asdl_seq_LEN(ops); i++) {
        int op;
        expr_ty arg;
        asdl_seq *elts;

        op = asdl_seq_GET(ops, i);
        arg = (expr_ty)asdl_seq_GET(args, i);
        /* Change literal list or set in 'in' or 'not in' into
           tuple or frozenset respectively. */
        /* TODO: do the same when list or set is used as iterable
           in for loop and comprehensions? */
        if (op != In && op != NotIn)
            continue;
        if (arg->kind == List_kind)
            elts = arg->v.List.elts;
        else if (arg->kind == Set_kind)
            elts = arg->v.Set.elts;
        else continue;

        newval = make_const_tuple(elts, arg->kind == Set_kind);
        make_const(arg, newval, arena);
    }
    return 1;
}

@visitor(astfold, PyArena*, mod)

int _PyAST_Optimize(mod_ty mod, PyArena *arena)
{
    int ret = astfold_mod(mod, arena);
    assert(ret || PyErr_Occurred());
    return ret;
}

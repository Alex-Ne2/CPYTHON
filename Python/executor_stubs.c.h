// This file is generated by Tools/cases_generator/tier2_generator.py
// from:
//   Python/bytecodes.c
// Do not edit!

#ifdef TIER_ONE
    #error "This file is for Tier 2 only"
#endif
#define TIER_TWO 2

#undef JUMP_TO_ERROR
#define JUMP_TO_ERROR() { *_stack_pointer = stack_pointer; return 1; }

#undef JUMP_TO_JUMP_TARGET
#define JUMP_TO_JUMP_TARGET() { *_stack_pointer = stack_pointer; return 2; }

        int _STORE_NAME_func(PyThreadState *tstate, _PyInterpreterFrame *frame, PyObject ***_stack_pointer, int oparg) {
            PyObject **stack_pointer = *_stack_pointer;
            PyObject *v;
            v = stack_pointer[-1];
            PyObject *name = GETITEM(FRAME_CO_NAMES, oparg);
            PyObject *ns = LOCALS();
            int err;
            if (ns == NULL) {
                _PyErr_Format(tstate, PyExc_SystemError,
                              "no locals found when storing %R", name);
                Py_DECREF(v);
                if (true) JUMP_TO_ERROR();
            }
            if (PyDict_CheckExact(ns))
            err = PyDict_SetItem(ns, name, v);
            else
            err = PyObject_SetItem(ns, name, v);
            Py_DECREF(v);
            if (err) JUMP_TO_ERROR();
            stack_pointer += -1;
            *_stack_pointer = stack_pointer;
            return 0;
        }

        int _BUILD_STRING_func(PyThreadState *tstate, _PyInterpreterFrame *frame, PyObject ***_stack_pointer, int oparg) {
            PyObject **stack_pointer = *_stack_pointer;
            PyObject **pieces;
            PyObject *str;
            pieces = &stack_pointer[-oparg];
            str = _PyUnicode_JoinArray(&_Py_STR(empty), pieces, oparg);
            for (int _i = oparg; --_i >= 0;) {
                Py_DECREF(pieces[_i]);
            }
            if (str == NULL) JUMP_TO_ERROR();
            stack_pointer[-oparg] = str;
            stack_pointer += 1 - oparg;
            *_stack_pointer = stack_pointer;
            return 0;
        }

        int _BUILD_MAP_func(PyThreadState *tstate, _PyInterpreterFrame *frame, PyObject ***_stack_pointer, int oparg) {
            PyObject **stack_pointer = *_stack_pointer;
            PyObject **values;
            PyObject *map;
            values = &stack_pointer[-oparg*2];
            map = _PyDict_FromItems(
                                    values, 2,
                                    values+1, 2,
                                    oparg);
            for (int _i = oparg*2; --_i >= 0;) {
                Py_DECREF(values[_i]);
            }
            if (map == NULL) JUMP_TO_ERROR();
            stack_pointer[-oparg*2] = map;
            stack_pointer += 1 - oparg*2;
            *_stack_pointer = stack_pointer;
            return 0;
        }

        int _BUILD_CONST_KEY_MAP_func(PyThreadState *tstate, _PyInterpreterFrame *frame, PyObject ***_stack_pointer, int oparg) {
            PyObject **stack_pointer = *_stack_pointer;
            PyObject *keys;
            PyObject **values;
            PyObject *map;
            keys = stack_pointer[-1];
            values = &stack_pointer[-1 - oparg];
            assert(PyTuple_CheckExact(keys));
            assert(PyTuple_GET_SIZE(keys) == (Py_ssize_t)oparg);
            map = _PyDict_FromItems(
                                    &PyTuple_GET_ITEM(keys, 0), 1,
                                    values, 1, oparg);
            for (int _i = oparg; --_i >= 0;) {
                Py_DECREF(values[_i]);
            }
            Py_DECREF(keys);
            if (map == NULL) JUMP_TO_ERROR();
            stack_pointer[-1 - oparg] = map;
            stack_pointer += -oparg;
            *_stack_pointer = stack_pointer;
            return 0;
        }

        int _LOAD_SUPER_ATTR_METHOD_func(PyThreadState *tstate, _PyInterpreterFrame *frame, PyObject ***_stack_pointer, int oparg) {
            PyObject **stack_pointer = *_stack_pointer;
            PyObject *self;
            PyObject *class;
            PyObject *global_super;
            PyObject *attr;
            PyObject *self_or_null;
            self = stack_pointer[-1];
            class = stack_pointer[-2];
            global_super = stack_pointer[-3];
            assert(oparg & 1);
            if (global_super != (PyObject *)&PySuper_Type) JUMP_TO_JUMP_TARGET();
            if (!PyType_Check(class)) JUMP_TO_JUMP_TARGET();
            STAT_INC(LOAD_SUPER_ATTR, hit);
            PyObject *name = GETITEM(FRAME_CO_NAMES, oparg >> 2);
            PyTypeObject *cls = (PyTypeObject *)class;
            int method_found = 0;
            attr = _PySuper_Lookup(cls, self, name,
                                   Py_TYPE(self)->tp_getattro == PyObject_GenericGetAttr ? &method_found : NULL);
            Py_DECREF(global_super);
            Py_DECREF(class);
            if (attr == NULL) {
                Py_DECREF(self);
                if (true) JUMP_TO_ERROR();
            }
            if (method_found) {
                self_or_null = self; // transfer ownership
            } else {
                Py_DECREF(self);
                self_or_null = NULL;
            }
            stack_pointer[-3] = attr;
            stack_pointer[-2] = self_or_null;
            stack_pointer += -1;
            *_stack_pointer = stack_pointer;
            return 0;
        }

        int _INIT_CALL_PY_EXACT_ARGS_func(PyThreadState *tstate, _PyInterpreterFrame *frame, PyObject ***_stack_pointer, int oparg) {
            PyObject **stack_pointer = *_stack_pointer;
            PyObject **args;
            PyObject *self_or_null;
            PyObject *callable;
            _PyInterpreterFrame *new_frame;
            args = &stack_pointer[-oparg];
            self_or_null = stack_pointer[-1 - oparg];
            callable = stack_pointer[-2 - oparg];
            int has_self = (self_or_null != NULL);
            STAT_INC(CALL, hit);
            PyFunctionObject *func = (PyFunctionObject *)callable;
            new_frame = _PyFrame_PushUnchecked(tstate, func, oparg + has_self);
            PyObject **first_non_self_local = new_frame->localsplus + has_self;
            new_frame->localsplus[0] = self_or_null;
            for (int i = 0; i < oparg; i++) {
                first_non_self_local[i] = args[i];
            }
            stack_pointer[-2 - oparg] = (PyObject *)new_frame;
            stack_pointer += -1 - oparg;
            *_stack_pointer = stack_pointer;
            return 0;
        }

        int _CALL_BUILTIN_FAST_WITH_KEYWORDS_func(PyThreadState *tstate, _PyInterpreterFrame *frame, PyObject ***_stack_pointer, int oparg) {
            PyObject **stack_pointer = *_stack_pointer;
            PyObject **args;
            PyObject *self_or_null;
            PyObject *callable;
            PyObject *res;
            args = &stack_pointer[-oparg];
            self_or_null = stack_pointer[-1 - oparg];
            callable = stack_pointer[-2 - oparg];
            /* Builtin METH_FASTCALL | METH_KEYWORDS functions */
            int total_args = oparg;
            if (self_or_null != NULL) {
                args--;
                total_args++;
            }
            if (!PyCFunction_CheckExact(callable)) JUMP_TO_JUMP_TARGET();
            if (PyCFunction_GET_FLAGS(callable) != (METH_FASTCALL | METH_KEYWORDS)) JUMP_TO_JUMP_TARGET();
            STAT_INC(CALL, hit);
            /* res = func(self, args, nargs, kwnames) */
            PyCFunctionFastWithKeywords cfunc =
            (PyCFunctionFastWithKeywords)(void(*)(void))
            PyCFunction_GET_FUNCTION(callable);
            res = cfunc(PyCFunction_GET_SELF(callable), args, total_args, NULL);
            assert((res != NULL) ^ (_PyErr_Occurred(tstate) != NULL));
            /* Free the arguments. */
            for (int i = 0; i < total_args; i++) {
                Py_DECREF(args[i]);
            }
            Py_DECREF(callable);
            if (res == NULL) JUMP_TO_ERROR();
            stack_pointer[-2 - oparg] = res;
            stack_pointer += -1 - oparg;
            *_stack_pointer = stack_pointer;
            return 0;
        }

        int _CALL_METHOD_DESCRIPTOR_O_func(PyThreadState *tstate, _PyInterpreterFrame *frame, PyObject ***_stack_pointer, int oparg) {
            PyObject **stack_pointer = *_stack_pointer;
            PyObject **args;
            PyObject *self_or_null;
            PyObject *callable;
            PyObject *res;
            args = &stack_pointer[-oparg];
            self_or_null = stack_pointer[-1 - oparg];
            callable = stack_pointer[-2 - oparg];
            int total_args = oparg;
            if (self_or_null != NULL) {
                args--;
                total_args++;
            }
            PyMethodDescrObject *method = (PyMethodDescrObject *)callable;
            if (total_args != 2) JUMP_TO_JUMP_TARGET();
            if (!Py_IS_TYPE(method, &PyMethodDescr_Type)) JUMP_TO_JUMP_TARGET();
            PyMethodDef *meth = method->d_method;
            if (meth->ml_flags != METH_O) JUMP_TO_JUMP_TARGET();
            // CPython promises to check all non-vectorcall function calls.
            if (tstate->c_recursion_remaining <= 0) JUMP_TO_JUMP_TARGET();
            PyObject *arg = args[1];
            PyObject *self = args[0];
            if (!Py_IS_TYPE(self, method->d_common.d_type)) JUMP_TO_JUMP_TARGET();
            STAT_INC(CALL, hit);
            PyCFunction cfunc = meth->ml_meth;
            _Py_EnterRecursiveCallTstateUnchecked(tstate);
            res = _PyCFunction_TrampolineCall(cfunc, self, arg);
            _Py_LeaveRecursiveCallTstate(tstate);
            assert((res != NULL) ^ (_PyErr_Occurred(tstate) != NULL));
            Py_DECREF(self);
            Py_DECREF(arg);
            Py_DECREF(callable);
            if (res == NULL) JUMP_TO_ERROR();
            stack_pointer[-2 - oparg] = res;
            stack_pointer += -1 - oparg;
            *_stack_pointer = stack_pointer;
            return 0;
        }

#undef JUMP_TO_ERROR
#undef JUMP_TO_JUMP_TARGET
#define JUMP_TO_JUMP_TARGET() goto jump_to_jump_target
#define JUMP_TO_ERROR() goto jump_to_error_target
#undef TIER_TWO

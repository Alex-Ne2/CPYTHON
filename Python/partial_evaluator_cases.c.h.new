// This file is generated by Tools/cases_generator/partial_evaluator_generator.py
// from:
//   Python/partial_evaluator_bytecodes.c
// Do not edit!

        case _NOP: {
            break;
        }

        case _CHECK_PERIODIC: {
            MATERIALIZE_INST();
            materialize_ctx(ctx);
            break;
        }

        case _CHECK_PERIODIC_IF_NOT_YIELD_FROM: {
            MATERIALIZE_INST();
            materialize_ctx(ctx);
            break;
        }

        /* _QUICKEN_RESUME is not a viable micro-op for tier 2 */

        case _RESUME_CHECK: {
            MATERIALIZE_INST();
            break;
        }

        /* _MONITOR_RESUME is not a viable micro-op for tier 2 */

        case _LOAD_FAST_CHECK: {
            _Py_UopsPESlot value;
            MATERIALIZE_INST();
            value = GETLOCAL(oparg);
            // We guarantee this will error - just bail and don't optimize it.
            if (sym_is_null(&value)) {
                ctx->done = true;
            }
            stack_pointer[0] = value;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _LOAD_FAST: {
            _Py_UopsPESlot value;
            value = GETLOCAL(oparg);
            sym_set_origin_inst_override(&value, this_instr);
            stack_pointer[0] = value;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _LOAD_FAST_AND_CLEAR: {
            _Py_UopsPESlot value;
            MATERIALIZE_INST();
            value = GETLOCAL(oparg);
            GETLOCAL(oparg) = sym_new_null(ctx);
            sym_set_origin_inst_override(&value, this_instr);
            stack_pointer[0] = value;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _LOAD_CONST: {
            _Py_UopsPESlot value;
            // Should've all been converted by specializer.
            Py_UNREACHABLE();